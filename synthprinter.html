<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>synthprinter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>synthprinter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import cadquery as cq


class SynthPrinter:
    &#34;&#34;&#34;Each SynthPrinter object corresponds to a panel. You must add one, and
    only one panel, before performing operations on it.

    Once you&#39;re done placing elements, you must call `render()` before
    exporting your work, to post-process things correctly.
    Elements will be aligned and oriented wrong if you skip this call.

    The naming convention of methods is as follows:

    - `addX()`: calls methods such as `cutX()`, `previewX()`, etc, operating on multiple
    layers. Skips drawing to disabled layers for performance, so disable unnecessary
    layers in the constructor while making your layout.
    In most cases, you want to call those methods instead of making the individual calls
    bundled in the `addX()` methods.
    - `cutX()`: makes a hole for X on the **panel** layer
    - `markX()`: draws marks for X on the **drillTemplate** layer.
    _[Exporting a drill template is a WIP, it still takes a bit of tinkering to
    make the PDF the proper size]_
    - `previewX()`: draws boxes and cylinders to preview the size of footprints
    on the **preview** layer
    - `embossX()`: creates an element on the **emboss** layer. You can only 3D print
    embossings if you orient your panel with the back as the first layer.
    _[Not implemented yet]_
    - `engraveX()`: carves an engraving that does not cut all the way through the
    **panel** layer
    - `supportX()`: creates an element on the **supports** layer, used to strenghten
    panels and hold in place PCBs. You can only 3D print supports if you orient
    your panel with the front as the first layer.

    Be sure to take a look at the bundled examples!
    &#34;&#34;&#34;

    defaultConfig = {
        ###########################################################
        # You can override any of these settings from the defaultConfig by
        # passing them as a parameter to the constructor.
        #
        # Preview objects have their sizes hardcoded to keep
        # the size of this config in check.
        #
        ###########################################################
        ### Common Dimensions
        ###########################################################
        &#34;tolerance&#34;: 0.4,
        &#34;panelWidth&#34;: 100.0,
        &#34;panelHeight&#34;: 100.0,
        &#34;panelThickness&#34;: 4.0,
        &#34;hp&#34;: 5.08,  # 0.2 inches
        &#34;khp&#34;: 25,  # Kosmo horizontal pitch
        # default depth of 1.02mm, to ensure that at 0.20mm print settings,
        # it hollows out 5 layers instead of 4. This helps making the notches
        # better at keeping things in place.
        &#34;retainingNotchDepth&#34;: lambda config: config[&#34;panelThickness&#34;] / 3.9,
        ###########################################################
        ### Visualization in CQ Editor
        ###########################################################
        &#34;panelRender&#34;: True,
        &#34;supportsRender&#34;: True,
        &#34;embossRender&#34;: True,
        &#34;previewRender&#34;: True,  # Disable to improve render performance
        &#34;drillTemplateRender&#34;: False,
        &#34;panelShowOptions&#34;: {&#34;alpha&#34;: 0.2, &#34;color&#34;: (0, 180, 230)},
        &#34;supportsShowOptions&#34;: {&#34;alpha&#34;: 0.1, &#34;color&#34;: (180, 230, 0)},
        &#34;embossShowOptions&#34;: {&#34;alpha&#34;: 0.2, &#34;color&#34;: (50, 180, 230)},
        &#34;previewShowOptions&#34;: {&#34;alpha&#34;: 0.65, &#34;color&#34;: (100, 30, 30)},
        &#34;drillTemplateShowOptions&#34;: {&#34;alpha&#34;: 0.1, &#34;color&#34;: (20, 20, 20)},
        ###########################################################
        ### Screws
        ###########################################################
        ###### M3
        &#34;m3Diameter&#34;: 3.0,
        &#34;m3DiameterWithTolerance&#34;: lambda config: config[&#34;m3Diameter&#34;]
        + config[&#34;tolerance&#34;],
        &#34;m3screwSlotWidth&#34;: lambda config: config[&#34;m3DiameterWithTolerance&#34;] * 2.5,
        &#34;m3screwSlotHeight&#34;: lambda config: config[&#34;m3DiameterWithTolerance&#34;],
        &#34;m3screwSlotDistanceFromTop&#34;: 3.0,
        &#34;m3screwSlotDistanceFromBottom&#34;: 3.0,
        &#34;m3screwSlotDistanceFromSide&#34;: lambda config: config[&#34;m3DiameterWithTolerance&#34;]
        * 1.5,
        ###### M2
        &#34;m2Diameter&#34;: 2.0,
        &#34;m2DiameterWithTolerance&#34;: lambda config: config[&#34;m2Diameter&#34;]
        + config[&#34;tolerance&#34;] * 1.5,  # More expansion with small screws
        ###########################################################
        ### Panels
        ###########################################################
        &#34;eurorackHeight&#34;: 128.5,  # Modules are smaller than the full 3U
        &#34;eurorackWidthTolerance&#34;: lambda config: config[&#34;tolerance&#34;],
        &#34;1UIJHeight&#34;: 39.65,  # Itellijel 1U - for our purposes, normal Euro but 1U tall
        &#34;1UIJWidthTolerance&#34;: lambda config: config[&#34;tolerance&#34;],
        &#34;kosmoHeight&#34;: 200.0,
        &#34;kosmoWidthTolerance&#34;: 0,  # Kosmo needs no additional tolerance as HP rails are larger
        &#34;panelWidthTolerance&#34;: 0,  # Set when adding the panel
        ###########################################################
        ### Panel engravings
        ###########################################################
        &#34;panelEngravingDepth&#34;: lambda config: config[&#34;panelThickness&#34;] / 3,
        ###########################################################
        ### Rails &amp; Cradles
        ###########################################################
        &#34;railsFrontRecess&#34;: 2,  # 1.6 PCB + junk leftover from supports
        &#34;railsSupportDepthBack&#34;: 4.0,  # How much to protrude behind panel, not full depth
        &#34;railsHeight&#34;: 8,
        &#34;railsScrewDiameter&#34;: lambda config: config[
            &#34;m3Diameter&#34;
        ],  # Not adding the tolerance holds better
        &#34;cradleTolerance&#34;: lambda config: config[&#34;tolerance&#34;],
        ###########################################################
        ### Buttons and switches
        ###########################################################
        ###### Arcade
        # Sanwas have little clips making them require more tolerance
        # and the 24mm one require a thinner panel than the default
        # to snap in properly
        &#34;arcade24mmButton&#34;: 24,
        &#34;arcade24mmButtonWithTolerance&#34;: lambda config: config[&#34;arcade24mmButton&#34;]
        + config[&#34;tolerance&#34;] * 1.4,
        &#34;arcade24mmButtonAdditionalClearanceDiameter&#34;: 27,
        &#34;arcade24mmButtonAdditionalClearanceDepth&#34;: lambda config: config[
            &#34;retainingNotchDepth&#34;
        ],
        &#34;arcade30mmButton&#34;: 30,
        &#34;arcade30mmButtonWithTolerance&#34;: lambda config: config[&#34;arcade30mmButton&#34;]
        + config[&#34;tolerance&#34;] * 1.4,
        ###### Mini Toggle Switches
        &#34;miniToggleSwitchWidth&#34;: 13.2,
        &#34;miniToggleSwitchLength&#34;: 7.9,
        &#34;miniToggleSwitchDiameter&#34;: 6,
        &#34;miniToggleSwitchWidthWithTolerance&#34;: lambda config: config[
            &#34;miniToggleSwitchWidth&#34;
        ]
        + config[&#34;tolerance&#34;],
        &#34;miniToggleSwitchLengthWithTolerance&#34;: lambda config: config[
            &#34;miniToggleSwitchLength&#34;
        ]
        + config[&#34;tolerance&#34;],
        &#34;miniToggleSwitchDiameterWithTolerance&#34;: lambda config: config[
            &#34;miniToggleSwitchDiameter&#34;
        ]
        + config[&#34;tolerance&#34;],
        &#34;miniToggleSwitchNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        ###########################################################
        ### Potentiometers and rotary encoders
        ###########################################################
        ###### Pots
        &#34;potentiometerHoleDiameter&#34;: 7,
        &#34;potentiometerHoleDiameterWithTolerance&#34;: lambda config: config[
            &#34;potentiometerHoleDiameter&#34;
        ]
        + config[&#34;tolerance&#34;],
        &#34;potentiometerNotchDistanceFromCenter&#34;: 6.9,
        &#34;potentiometerNotchDiameter&#34;: 3.9,
        &#34;potentiometerNotchDepth&#34;: lambda config: config[&#34;panelThickness&#34;] / 1.5,
        &#34;rotaryEncoderWidth&#34;: 14,
        &#34;rotaryEncoderWidthWithTolerance&#34;: lambda config: config[&#34;rotaryEncoderWidth&#34;]
        + config[&#34;tolerance&#34;],
        &#34;rotaryEncoderHeight&#34;: 12,
        &#34;rotaryEncoderHeightWithTolerance&#34;: lambda config: config[&#34;rotaryEncoderHeight&#34;]
        + config[&#34;tolerance&#34;],
        &#34;rotaryEncoderNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        &#34;sliderNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        ###########################################################
        ### Jacks &amp; Sockets
        ###########################################################
        ###### Big
        &#34;bigJackDiameter&#34;: 9,
        &#34;bigJackDiameterWithTolerance&#34;: lambda config: config[&#34;bigJackDiameter&#34;]
        + config[&#34;tolerance&#34;],
        &#34;bigJackWidth&#34;: 16,
        &#34;bigJackHeight&#34;: lambda config: config[&#34;bigJackWidth&#34;],
        &#34;bigJackWidthWithTolerance&#34;: lambda config: config[&#34;bigJackWidth&#34;]
        + config[&#34;tolerance&#34;],
        &#34;bigJackHeightWithTolerance&#34;: lambda config: config[&#34;bigJackHeight&#34;]
        + config[&#34;tolerance&#34;],
        &#34;bigJackNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        ###### Mini
        &#34;miniJackDiameter&#34;: 6,
        &#34;miniJackDiameterWithTolerance&#34;: lambda config: config[&#34;miniJackDiameter&#34;]
        + config[&#34;tolerance&#34;],
        &#34;miniJackSize&#34;: 9.5,
        &#34;miniJackSizeWithTolerance&#34;: lambda config: config[&#34;miniJackSize&#34;]
        + config[&#34;tolerance&#34;] * 2,
        &#34;miniJackNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        ###### MIDI
        &#34;midiSocketDiameter&#34;: 15,
        &#34;midiSocketDiameterWithTolerance&#34;: lambda config: config[&#34;midiSocketDiameter&#34;]
        + config[&#34;tolerance&#34;] * 2,
        &#34;midiSocketScrewDistance&#34;: 21.6,
        &#34;midiSocketScrewDiameterWithTolerance&#34;: lambda config: config[
            &#34;m3DiameterWithTolerance&#34;
        ],
        ###########################################################
        ### Blinkenlichten
        ###########################################################
        &#34;5mmLed&#34;: 4.9,
        &#34;5mmLedWithTolerance&#34;: lambda config: config[&#34;5mmLed&#34;] + config[&#34;tolerance&#34;],
        &#34;3mmLed&#34;: 2.9,
        &#34;3mmLedWithTolerance&#34;: lambda config: config[&#34;3mmLed&#34;]
        + config[&#34;tolerance&#34;] * 1.5,
        ###########################################################
        ### Drill Template
        ###########################################################
        &#34;DrillTemplateMarkLength&#34;: 10,
        &#34;DrillTemplateMarkThickness&#34;: 0.2,
        &#34;DrillTemplateDistance&#34;: -80,
    }
    &#34;&#34;&#34;
    You can override any of the defaultConfig settings by passing them as a
    parameter to the constructor. Look at the code for the full list of
    settings. Some are dynamically calculated from other settings, 
    in particular, the tolerances of most elements are expressed as a
    multiplier of the main tolerance value.

    For example, to replace the main tolerance value of 0.4mm, create a
    new object as follows:

        sp = SynthPrinter(
            tolerance=0.6,
        )

    defaultConfig values are mostly dimensions that have been tested to
    work well with 3D printing. You are encouraged to try out the defaults 
    first. But with a different process than FDM 3D printing, you will want to
    make your own configuration profile.&#34;&#34;&#34;

    def __init__(self, **kwargs):
        self.config = self.defaultConfig.copy()

        # override defaults
        for key, value in kwargs.items():
            if key in self.config:
                self.config[key] = value

        # call lambdas
        for key, value in self.config.items():
            if callable(value):
                self.config[key] = value(self.config)

        # Create layers
        self.panel = cq.Workplane(&#34;XY&#34;)
        self.preview = cq.Workplane(&#34;XY&#34;)
        self.emboss = cq.Workplane(&#34;XY&#34;)
        self.supports = cq.Workplane(&#34;XY&#34;)
        self.drillTemplate = cq.Workplane(&#34;XY&#34;)

        self.panelAdded = False  # We can only have one or horrible things happen

    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################

    #######################################################################
    ### Rendering &amp; Export
    #######################################################################

    def render(self, show_object=False):
        &#34;&#34;&#34;You must call this before displaying or exporting your panel
        to post-process it properly.

        If you give it the show_object function from Cq Editor as an
        argument, it will also display the object. When using Synth Printer
        from a different environment, just call without any argument.
        &#34;&#34;&#34;
        # Shave off the sides of the panel if needed
        self.cutPanelWidthTolerance()
        # Move the supports where they belong
        self.supports = self.supports.translate(
            (0, 0, self.config[&#34;panelThickness&#34;] / 2)
        )
        # Move the drill template above the panel
        self.drillTemplate = self.drillTemplate.translate(
            (0, 0, self.config[&#34;DrillTemplateDistance&#34;])
        )
        # Rotate the layers for viewing
        self.panel = self.panel.rotate((0, 0, 0), (1, 0, 0), 180)
        self.preview = self.preview.rotate((0, 0, 0), (1, 0, 0), 180)
        self.emboss = self.emboss.rotate((0, 0, 0), (1, 0, 0), 180)
        self.supports = self.supports.rotate((0, 0, 0), (1, 0, 0), 180)
        self.drillTemplate = self.drillTemplate.rotate((0, 0, 0), (1, 0, 0), 180)
        # Display the layers if we&#39;re in CQ Editor
        if show_object and self.config[&#34;panelRender&#34;]:
            show_object(
                self.panel,
                name=&#34;panel&#34;,
                options=self.config[&#34;panelShowOptions&#34;],
            )
        if show_object and self.config[&#34;supportsRender&#34;]:
            show_object(
                self.supports,
                name=&#34;supports&#34;,
                options=self.config[&#34;supportsShowOptions&#34;],
            )
        if show_object and self.config[&#34;embossRender&#34;]:
            show_object(
                self.emboss,
                name=&#34;emboss&#34;,
                options=self.config[&#34;embossShowOptions&#34;],
            )
        if show_object and self.config[&#34;previewRender&#34;]:
            show_object(
                self.preview,
                name=&#34;preview&#34;,
                options=self.config[&#34;previewShowOptions&#34;],
            )
        if show_object and self.config[&#34;drillTemplateRender&#34;]:
            show_object(
                self.drillTemplate,
                name=&#34;drillTemplate&#34;,
                options=self.config[&#34;drillTemplateShowOptions&#34;],
            )

    def exportDrillTemplate(self, filename: str = &#34;DrillTemplate.svg&#34;):
        &#34;&#34;&#34;Exports the drill template as a SVG file.

        Before you print it, crop and scale it up or down in image editing
        software to match the size of one side!

        TODO: Make it the perfect size out of the box.

        You must activate the layer in the constructor first! Otherwise,
        drill marks are not rendered, for performance.&#34;&#34;&#34;
        cq.exporters.export(
            self.drillTemplate,
            filename,
            opt={
                &#34;width&#34;: 2000,
                &#34;height&#34;: 2000,
                &#34;marginLeft&#34;: 0,
                &#34;marginTop&#34;: 0,
                &#34;showAxes&#34;: False,
                &#34;projectionDir&#34;: (0.0, 0.0, 1.0),
                &#34;strokeWidth&#34;: 0.25,
                &#34;strokeColor&#34;: (255, 0, 0),
                &#34;hiddenColor&#34;: (0, 0, 255),
                &#34;showHidden&#34;: False,
            },
        )

    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################

    #######################################################################
    ### Basic operations
    #######################################################################

    def cutHole(self, x: float, y: float, diameter: float, depth: float = None):
        &#34;&#34;&#34;Makes a circular hole, default depth is through the entire panel

        x, y define the center.&#34;&#34;&#34;
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .hole(diameter, depth)
        )

    def cutRect(
        self,
        x: float,
        y: float,
        width: float,
        height: float,
        depth: float = 0,
        centered: bool = True,
    ):
        &#34;&#34;&#34;Cuts a rectangular shape through the panel.

        x, y define the center

        `depth = 0` cuts through all.
        &#34;&#34;&#34;

        if depth == 0:
            depth = self.config[&#34;panelThickness&#34;]

        cutout = cq.Workplane(&#34;XY&#34;).box(width, height, depth)

        if centered:
            cutout = cutout.translate(
                (
                    -self.config[&#34;panelWidth&#34;] / 2 + x,
                    -self.config[&#34;panelHeight&#34;] / 2 + y,
                    0,
                )
            )
        else:
            cutout = cutout.translate(
                (
                    -self.config[&#34;panelWidth&#34;] / 2 + x + width / 2,
                    -self.config[&#34;panelHeight&#34;] / 2 + y + height / 2,
                    0,
                )
            )

        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .cut(cutout)
        )

    # TODO: Top-left support!
    def previewCylinderOnBack(self, x: float, y: float, diameter: float, depth: float):
        &#34;&#34;&#34;Adds a cylinder for preview on the back of the panel.
        It will be deeper by half the panel thickness.

        x, y define the center.&#34;&#34;&#34;
        self.preview = (
            self.preview.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .circle(diameter / 2)
            .extrude(depth + self.config[&#34;panelThickness&#34;] / 2)
        )

    def previewCylinderOnFront(self, x: float, y: float, diameter: float, depth: float):
        &#34;&#34;&#34;Adds a cylinder for preview on the front of the panel.
        It will be deeper by half the panel thickness.

        x, y define the center.&#34;&#34;&#34;
        self.preview = (
            self.preview.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .circle(diameter / 2)
            .extrude(-depth - self.config[&#34;panelThickness&#34;] / 2)
        )

    def previewBoxOnBack(
        self, x: float, y: float, width: float, height: float, depth: float
    ):
        &#34;&#34;&#34;Adds a box for preview on the back of the panel.
        It will be deeper by half the panel thickness.

        x, y define the center.&#34;&#34;&#34;
        self.preview = (
            self.preview.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(width, height)
            .extrude(depth + self.config[&#34;panelThickness&#34;] / 2)
        )

    def previewBoxOnFront(
        self, x: float, y: float, width: float, height: float, depth: float
    ):
        &#34;&#34;&#34;Adds a box for preview on the front of the panel.
        It will be deeper by half the panel thickness.

        x, y define the center.
        &#34;&#34;&#34;
        self.preview = (
            self.preview.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(width, height)
            .extrude(-depth - self.config[&#34;panelThickness&#34;] / 2)
        )

    #######################################################################
    ### Panels
    #######################################################################

    def addPanel(
        self,
        width: float,
        height: float,
        screwSlots: str = &#34;auto&#34;,
    ):
        &#34;&#34;&#34;Adds a rectangular panel of arbitrary dimensions.
        You can only add one.

        Screw slots in the corners provide better tolerances than holes
        in a DIY printed system. If the panel is too small for four slots,
        there will be only two by default.


        TODO: Add Slots to the drill template


        screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
        &#34;&#34;&#34;

        if self.panelAdded == True:
            raise Warning(&#34;Only one panel can be added&#34;)
        else:
            self.panelAdded = True

        self.config[&#34;panelWidth&#34;] = width
        self.config[&#34;panelHeight&#34;] = height

        # Make the main panel shape
        self.panel = self.panel.box(
            self.config[&#34;panelWidth&#34;],
            self.config[&#34;panelHeight&#34;],
            self.config[&#34;panelThickness&#34;],
        )

        # Initialize the drill template
        self.markOutline()

        # Do we add screw slots?
        # default to &#34;none&#34; configuration
        screwSlotTopLeft = False
        screwSlotTopCenter = False
        screwSlotTopRight = False
        screwSlotBottomLeft = False
        screwSlotBottomCenter = False
        screwSlotBottomRight = False
        if (  # If too small for 4 slots
            self.config[&#34;m3screwSlotWidth&#34;] * 2
            + (
                self.config[&#34;m3screwSlotDistanceFromSide&#34;]
                - self.config[&#34;m3screwSlotWidth&#34;] / 2
            )
            * 2
        ) &gt; self.config[&#34;panelWidth&#34;]:
            if screwSlots == &#34;auto&#34;:
                screwSlots = &#34;tlbr&#34;
            if screwSlots == &#34;auto-tlbr&#34;:
                screwSlots = &#34;tlbr&#34;
            if screwSlots == &#34;auto-trbl&#34;:
                screwSlots = &#34;trbl&#34;
            if screwSlots == &#34;auto-center&#34;:
                screwSlots = &#34;center&#34;
        else:  # Large enough for 4 slots
            if screwSlots == &#34;auto&#34;:
                screwSlots = &#34;all&#34;
            if screwSlots == &#34;auto-tlbr&#34;:
                screwSlots = &#34;all&#34;
            if screwSlots == &#34;auto-trbl&#34;:
                screwSlots = &#34;all&#34;
            if screwSlots == &#34;auto-center&#34;:
                screwSlots = &#34;all&#34;
        if screwSlots == &#34;tlbr&#34;:
            screwSlotTopLeft = True
            screwSlotBottomRight = True
        if screwSlots == &#34;trbl&#34;:
            screwSlotTopRight = True
            screwSlotBottomLeft = True
        if screwSlots == &#34;center&#34;:
            screwSlotTopCenter = True
            screwSlotBottomCenter = True
        if screwSlots == &#34;all&#34;:
            screwSlotTopLeft = True
            screwSlotTopRight = True
            screwSlotBottomLeft = True
            screwSlotBottomRight = True

        screwPoints = []
        if screwSlotTopLeft:
            screwPoints.append(
                (
                    self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                    self.config[&#34;panelHeight&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromTop&#34;],
                )
            )
        if screwSlotTopCenter:
            screwPoints.append(
                (
                    self.config[&#34;panelWidth&#34;] / 2,
                    self.config[&#34;panelHeight&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromTop&#34;],
                )
            )
        if screwSlotTopRight:
            screwPoints.append(
                (
                    self.config[&#34;panelWidth&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                    self.config[&#34;panelHeight&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromTop&#34;],
                )
            )
        if screwSlotBottomLeft:
            screwPoints.append(
                (
                    self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                    self.config[&#34;m3screwSlotDistanceFromBottom&#34;],
                )
            )
        if screwSlotBottomCenter:
            screwPoints.append(
                (
                    self.config[&#34;panelWidth&#34;] / 2,
                    self.config[&#34;m3screwSlotDistanceFromBottom&#34;],
                )
            )
        if screwSlotBottomRight:
            screwPoints.append(
                (
                    self.config[&#34;panelWidth&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                    self.config[&#34;m3screwSlotDistanceFromBottom&#34;],
                )
            )
        if screwPoints != []:
            self.panel = (
                self.panel.faces(&#34;&gt;Z&#34;)
                .workplane()
                .center(-self.config[&#34;panelWidth&#34;] / 2, -self.config[&#34;panelHeight&#34;] / 2)
                .pushPoints(screwPoints)
                .slot2D(
                    self.config[&#34;m3screwSlotWidth&#34;],
                    self.config[&#34;m3screwSlotHeight&#34;],
                    0,
                )
                .cutThruAll()
            )

    def addEurorackPanel(
        self,
        hp: int,
        screwSlots=&#34;auto&#34;,
    ):
        &#34;&#34;&#34;Adds a Eurorack panel with screw slots. Eurorack width is defined in hp().

        Eurorack sizes are generally an even number of hp, such as 4hp or 8hp.
        3hp and 5hp are the only odd number sizes commonly seen in commercial hardware.

        Screw slots in the corners provide better tolerances than holes
        in a DIY printed system. If the panel is too small for four slots,
        there will be only two by default.

        screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
        &#34;&#34;&#34;
        self.config[&#34;panelWidthTolerance&#34;] = self.config[&#34;eurorackWidthTolerance&#34;]
        self.addPanel(self.config[&#34;hp&#34;] * hp, self.config[&#34;eurorackHeight&#34;], screwSlots)

    def add1UIJPanel(
        self,
        hp: int,
        screwSlots=&#34;auto&#34;,
    ):
        &#34;&#34;&#34;Adds a 1U Tile (Intellijel size) panel with screw slots. Eurorack width is defined in hp().

        Note that there are two incompatible 1U tile standards: Intellijel and PulpLogic.

        Screw slots in the corners provide better tolerances than holes
        in a DIY printed system. If the panel is too small for four slots,
        there will be only two by default.

        screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
        &#34;&#34;&#34;
        self.config[&#34;panelWidthTolerance&#34;] = self.config[&#34;1UIJWidthTolerance&#34;]
        self.addPanel(self.config[&#34;hp&#34;] * hp, self.config[&#34;1UIJHeight&#34;], screwSlots)

    def addKosmoPanel(
        self,
        khp: int,
        screwSlots=&#34;auto&#34;,
    ):
        &#34;&#34;&#34;Adds a Kosmo panel with screw slots. khp argument is the amount of 25mm columns.

        Kosmo, also known as Metric 5U, is a format compatible with Eurorack
        popularized by Youtuber Sam Battle (Look Mum No Computer), that uses big jacks.
        It has a horizontal pitch of 25mm (called khp in Synth Printer for simplicity)

        Screw slots in the corners provide better tolerances than holes
        in a DIY printed system. Kosmo panels are always large enough for four slots,
        but you can explicitly set a different configuration of slots.

        screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
        &#34;&#34;&#34;
        self.config[&#34;panelWidthTolerance&#34;] = self.config[&#34;kosmoWidthTolerance&#34;]
        self.addPanel(
            self.config[&#34;khp&#34;] * khp,
            self.config[&#34;kosmoHeight&#34;],
            screwSlots=screwSlots,
        )

    def cutPanelWidthTolerance(self):
        &#34;&#34;&#34;Automatically called during `render()` for Eurorack and 1UIJ:
        makes the panel a bit smaller than its nominal size laterally to account
        for thermal expansion and misaligned neighboring panels.
        Kosmo panels are naturally a bit smaller than the hp grid (they are on a
        25mm grid, while hp are on a 5.08mm grid), as a result, they don&#39;t need
        this shave.
        &#34;&#34;&#34;
        # FIXME: Trial and error values that make no sense.
        # Something&#39;s broken elsewhere!
        # FIXME: Test print Euro / IJ: Do the tolerances provide enough extrusions?
        if self.config[&#34;panelWidthTolerance&#34;] == 0:
            return
        self.cutRect(
            0,
            0,
            self.config[&#34;panelWidthTolerance&#34;],
            self.config[&#34;panelHeight&#34;] * 2,
            False,
        )

        self.cutRect(
            self.config[&#34;panelWidth&#34;] - self.config[&#34;panelWidthTolerance&#34;] / 2,
            0,
            self.config[&#34;panelWidthTolerance&#34;],
            self.config[&#34;panelHeight&#34;] * 2,
            False,
        )

    #######################################################################
    ### Panel engravings
    #######################################################################

    def engraveLine(
        self,
        fromX: float,
        fromY: float,
        angle: float,
        length: float,
        width: float,
        depth: float = 0,
    ):
        &#34;&#34;&#34;Engraves a line on the front of the panel.

        If the depth parameter is omitted or 0, the default depth is used.

        Be sure to inspect both sides of the print to make sure there aren&#39;t
        any sections that are too thin!
        &#34;&#34;&#34;
        if not self.config[&#34;panelRender&#34;]:
            return
        if depth == 0:
            depth = self.config[&#34;panelEngravingDepth&#34;]
        cutout = (
            cq.Workplane(&#34;XY&#34;)
            .lineTo(-width / 2, 0)
            .lineTo(-width / 2, -length)
            .lineTo(width / 2, -length)
            .lineTo(width / 2, 0)
            .close()
            .extrude(depth)
            .rotate((0, 0, 0), (0, 0, 1), angle)
            .translate(
                (
                    -self.config[&#34;panelWidth&#34;] / 2 + fromX,
                    -self.config[&#34;panelHeight&#34;] / 2 + fromY,
                    -self.config[&#34;panelThickness&#34;] / 2,
                )
            )
        )
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .cut(cutout)
        )

    #######################################################################
    ### Rails
    #######################################################################

    # All this stuff is some real spaghetti.
    # It deserves a complete rewrite, and could take 1/5th the code.
    # But it works, so rewrite it yourself if you care.
    # Otherwise, don&#39;t bother me about it.

    def cutRail(
        self,
        x: float,
        y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
    ):
        &#34;&#34;&#34;Make a hole for a hp rail. The rail is added to the supports layer,
        not the panel layer.&#34;&#34;&#34;
        if not self.config[&#34;panelRender&#34;]:
            return
        width = hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2
        height = self.config[&#34;railsHeight&#34;] + self.config[&#34;cradleTolerance&#34;] * 2
        if orientation == &#34;vertical&#34;:
            width, height = height, width
        if centered:
            self.cutRect(x, y, width, height, 0, centered)
        else:
            self.cutRect(
                x - self.config[&#34;cradleTolerance&#34;],
                y - self.config[&#34;cradleTolerance&#34;],
                width,
                height,
                0,
                centered,
            )

    def supportRail(
        self,
        _x: float,
        _y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
    ):
        &#34;&#34;&#34;Adds a hp rail to the support layer. Requires a hole from cutRail().&#34;&#34;&#34;
        if not self.config[&#34;supportsRender&#34;]:
            return
        width = hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2
        height = self.config[&#34;railsHeight&#34;] + self.config[&#34;cradleTolerance&#34;] * 2
        if orientation != &#34;horizontal&#34;:
            width, height = height, width

        if centered:
            x = -self.config[&#34;panelWidth&#34;] / 2 + _x
            y = -self.config[&#34;panelHeight&#34;] / 2 + _y
        else:
            x = (
                -self.config[&#34;panelWidth&#34;] / 2
                + _x
                + width / 2
                - self.config[&#34;cradleTolerance&#34;]
            )
            y = (
                -self.config[&#34;panelHeight&#34;] / 2
                + _y
                + height / 2
                - self.config[&#34;cradleTolerance&#34;]
            )

        self.supports = (
            # Extrude on the inside
            self.supports.moveTo(x, y)
            .rect(width, height)
            .extrude(-self.config[&#34;panelThickness&#34;] + self.config[&#34;railsFrontRecess&#34;])
            # Extrude on the back
            .moveTo(x, y)
            .rect(width, height)
            .extrude(self.config[&#34;railsSupportDepthBack&#34;])
        )

        if orientation == &#34;horizontal&#34;:
            x = (
                -self.config[&#34;panelWidth&#34;] / 2
                + _x
                + (self.config[&#34;hp&#34;] - self.config[&#34;railsScrewDiameter&#34;]) / 2
                + self.config[&#34;railsScrewDiameter&#34;] / 2
            )
            if centered:
                x = x - hp(hpWidth) / 2
        else:
            y = (
                -self.config[&#34;panelHeight&#34;] / 2
                + _y
                + (self.config[&#34;hp&#34;] - self.config[&#34;railsScrewDiameter&#34;]) / 2
                + self.config[&#34;railsScrewDiameter&#34;] / 2
            )
            if centered:
                y = y - hp(hpWidth) / 2

        # Can&#39;t get rarray to work here.
        if orientation == &#34;horizontal&#34;:
            for n in range(hpWidth):
                self.supports = (
                    self.supports.moveTo(x + n * self.config[&#34;hp&#34;], y)
                    .circle(self.config[&#34;railsScrewDiameter&#34;] / 2)
                    .cutThruAll()
                )
        else:
            for n in range(hpWidth):
                self.supports = (
                    self.supports.moveTo(x, y + n * self.config[&#34;hp&#34;])
                    .circle(self.config[&#34;railsScrewDiameter&#34;] / 2)
                    .cutThruAll()
                )

    def addRail(
        self,
        x: float,
        y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
    ):
        &#34;&#34;&#34;Adds a recessed hp rail. The rail is added to the supports layer,
         not the panel layer. Good to build cradles: put a Eurorack modules on
        a Kosmo faceplate, or 1U on a Eurorack one.

        x, y define the center.

        orientation is &#34;horizontal&#34; by default, otherwise &#34;vertical&#34;
        &#34;&#34;&#34;
        self.cutRail(x, y, hpWidth, centered, orientation)
        self.supportRail(x, y, hpWidth, centered, orientation)

    def previewPanel(
        self,
        x: float,
        y: float,
        hpWidth: int,
        height: float,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
    ):
        if not self.config[&#34;previewRender&#34;]:
            return
        if orientation == &#34;horizontal&#34;:
            if centered:
                self.previewBoxOnFront(
                    x + self.config[&#34;cradleTolerance&#34;],
                    y
                    + height / 2
                    - self.config[&#34;railsHeight&#34;] / 2
                    + self.config[&#34;cradleTolerance&#34;] * 2,
                    hp(hpWidth),
                    height,
                    1.6,
                )
            else:
                self.previewBoxOnFront(
                    x + hp(hpWidth) / 2 + self.config[&#34;cradleTolerance&#34;],
                    y + height / 2 + self.config[&#34;cradleTolerance&#34;] * 2,
                    hp(hpWidth),
                    height,
                    1.6,
                )
        else:  # vertical
            if centered:
                self.previewBoxOnFront(
                    x
                    + height / 2
                    - self.config[&#34;railsHeight&#34;] / 2
                    + self.config[&#34;cradleTolerance&#34;] * 2,
                    y + self.config[&#34;cradleTolerance&#34;],
                    height,
                    hp(hpWidth),
                    1.6,
                )
            else:
                self.previewBoxOnFront(
                    x + height / 2 + self.config[&#34;cradleTolerance&#34;] * 2,
                    y + hp(hpWidth) / 2 + self.config[&#34;cradleTolerance&#34;],
                    height,
                    hp(hpWidth),
                    1.6,
                )

    def addCradle(
        self,
        x: float,
        y: float,
        hpWidth: int,
        height: float,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
        supportTop: bool = True,
        supportRight: bool = True,
        supportBottom: bool = True,
        supportLeft: bool = True,
    ):
        &#34;&#34;&#34;Adds a pair of recessed hp rails and a hole for modules.
        The rail is added to the supports layer, not the panel layer.
        You probably want to use `addEurorackCradle()` or
        `add1UIJCradle()` instead.
        &#34;&#34;&#34;
        # Add the two rails
        self.addRail(x, y, hpWidth, centered, orientation)
        if orientation == &#34;horizontal&#34;:
            self.addRail(
                x,
                y + height - self.config[&#34;m3Diameter&#34;] * 2,
                hpWidth,
                centered,
                orientation,
            )
        else:
            self.addRail(
                x + height - self.config[&#34;m3Diameter&#34;] * 2,
                y,
                hpWidth,
                centered,
                orientation,
            )
        # Cut a hole between those rails
        if orientation == &#34;horizontal&#34;:
            if centered:
                self.cutRect(
                    x,
                    y + height / 2 - self.config[&#34;railsHeight&#34;] / 2,
                    hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                    height + self.config[&#34;cradleTolerance&#34;] * 2,
                    0,
                    centered,
                )
                offset = -hp(hpWidth) / 2
                x1 = x - 3 + offset
                x2 = x + hp(hpWidth) + offset
                y1 = y - self.config[&#34;railsHeight&#34;] / 2 - 3
                y2 = y + height - 2
            else:
                self.cutRect(
                    x - self.config[&#34;cradleTolerance&#34;],
                    y - self.config[&#34;cradleTolerance&#34;],
                    hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                    height + self.config[&#34;cradleTolerance&#34;] * 2,
                    0,
                    centered,
                )
                offset = 0
                x1 = x - 3 + offset
                x2 = x + hp(hpWidth) + offset
                y1 = y - 3
                y2 = y + height + 2
            w = hp(hpWidth) + 6
            h = height + 6
        else:  # vertical
            if centered:
                self.cutRect(
                    x + height / 2 - self.config[&#34;railsHeight&#34;] / 2,
                    y,
                    height + self.config[&#34;cradleTolerance&#34;] * 2,
                    hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                    0,
                    centered,
                )
                x1 = (
                    x - self.config[&#34;railsHeight&#34;] * 0.7
                )  # FIXME: IDK why it needs this number. This prolly breaks alt values.
                x2 = x + height - 2
                y1 = y - hp(hpWidth) / 2 - 3
                y2 = y + hp(hpWidth) / 2
            else:
                self.cutRect(
                    x - self.config[&#34;cradleTolerance&#34;],
                    y - self.config[&#34;cradleTolerance&#34;],
                    height + self.config[&#34;cradleTolerance&#34;] * 2,
                    hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                    0,
                    centered,
                )
                x1 = x - 3
                x2 = x + height + 2
                y1 = y - 3
                y2 = y + hp(hpWidth)
            w = height + 6
            h = hp(hpWidth) + 6
        if supportTop:
            self.supportBar(
                x1,
                y1,
                w,
                3 + self.config[&#34;cradleTolerance&#34;] * 2,
                self.config[&#34;railsSupportDepthBack&#34;],
                False,
            )
        if supportBottom:
            self.supportBar(
                x1,
                y2 - self.config[&#34;cradleTolerance&#34;] * 2,
                w,
                3 + self.config[&#34;cradleTolerance&#34;] * 2,
                self.config[&#34;railsSupportDepthBack&#34;],
                False,
            )
        if supportLeft:
            self.supportBar(
                x1,
                y1,
                3 + self.config[&#34;cradleTolerance&#34;] * 2,
                h,
                self.config[&#34;railsSupportDepthBack&#34;],
                False,
            )
        if supportRight:
            self.supportBar(
                x2 - self.config[&#34;cradleTolerance&#34;] * 2,
                y1,
                3 + self.config[&#34;cradleTolerance&#34;] * 2,
                h,
                self.config[&#34;railsSupportDepthBack&#34;],
                False,
            )

        self.previewPanel(x, y, hpWidth, height, centered, orientation)

    def addEurorackCradle(
        self,
        x: float,
        y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
        supportTop: bool = True,
        supportRight: bool = True,
        supportBottom: bool = True,
        supportLeft: bool = True,
    ):
        &#34;&#34;&#34;Adds a pair of recessed hp rails and a hole for modules.
        The rail is added to the supports layer, not the panel layer.
        Screw holes are spaced vertically 122.5mm apart for Eurorack.
        There are supports around the cradle for increased strength.

        This footprint will probbly not work with custom values
        without modifying the code.

        Printed rails hold modules satisfactorily using M3x8mm screws, and
        the holes last a dozen screwing cycles before becoming too enlarged
        to hold things well. For increased safety, use longer screws and nuts.

        Strongly advised to print with supports, but will still print OK without.

        x, y define the center hole of the top rail if centered, that is,
        if the rail is 3hp, the coordinates define the center of the 2nd hole.
        If not centered, the coordinates define the top-left of the
        opening window.

        orientation is &#34;horizontal&#34; by default, otherwise &#34;vertical&#34;

        supportTop, supportRight, supportBottom, supportLeft can be set to False
        to allow stacking rails next to each other.&#34;&#34;&#34;
        self.addCradle(
            x,
            y,
            hpWidth,
            self.config[&#34;eurorackHeight&#34;],
            centered,
            orientation,
            supportTop,
            supportRight,
            supportBottom,
            supportLeft,
        )

    def add1UIJCradle(
        self,
        x: float,
        y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
        supportTop: bool = True,
        supportRight: bool = True,
        supportBottom: bool = True,
        supportLeft: bool = True,
    ):
        &#34;&#34;&#34;Adds a pair of recessed hp rails and a hole for modules.
        The rail is added to the supports layer, not the panel layer.
        Screw holes are spaced vertically 33.65mm apart for 1U (Intellijel).
        There are supports around the cradle for increased strength.

        This footprint will probbly not work with custom values
        without modifying the code.

        Printed rails hold modules satisfactorily using M3x8mm screws, and
        the holes last a dozen screwing cycles before becoming too enlarged
        to hold things well. For increased safety, use longer screws and nuts.

        Strongly advised to print with supports, but will still print OK without.

        x, y define the center hole of the top rail if centered, that is,
        if the rail is 3hp, the coordinates define the center of the 2nd hole.
        If not centered, the coordinates define the top-left of the
        opening window.

        orientation is &#34;horizontal&#34; by default, otherwise &#34;vertical&#34;

        supportTop, supportRight, supportBottom, supportLeft can be set to False
        to allow stacking rails next to each other.

        Note: This footprint is currently untested.
        &#34;&#34;&#34;
        self.addCradle(
            x,
            y,
            hpWidth,
            self.config[&#34;1UIJHeight&#34;],
            centered,
            orientation,
            supportTop,
            supportRight,
            supportBottom,
            supportLeft,
        )

    #######################################################################
    ### Support structures
    #######################################################################

    # Every function adding to the supports layer has support at the
    # start of the name.

    def supportBar(
        self,
        x: float,
        y: float,
        width: float,
        height: float,
        depth: float,
        centered: bool = False,
    ):
        &#34;&#34;&#34;Adds a box on the supports layer.

        x, y define the top-left of the box as seen from the front
        &#34;&#34;&#34;
        if not self.config[&#34;supportsRender&#34;]:
            return
        if centered:
            x = -self.config[&#34;panelWidth&#34;] / 2 + x
            y = -self.config[&#34;panelHeight&#34;] / 2 + y
        else:
            x = -self.config[&#34;panelWidth&#34;] / 2 + x + width / 2
            y = -self.config[&#34;panelHeight&#34;] / 2 + y + height / 2
        self.supports = (
            self.supports.moveTo(
                x,
                y,
            )
            .rect(width, height)
            .extrude(depth)
        )

    #######################################################################
    ### Drill template marks
    #######################################################################

    # Drill template marks are simple cross shapes that will more or less
    # look like crosses when exported at typical sizes.
    # Every function adding to the drillTemplate layer has mark at the
    # start of the name

    def markOutline(self):
        &#34;&#34;&#34;Add an outline to the drill template layer. This ensures proper
        SVG export. This is automatically done when adding a panel.&#34;&#34;&#34;

        self.drillTemplate = (
            self.drillTemplate.moveTo(  # Top
                0,
                -self.config[&#34;panelHeight&#34;] / 2
                + self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
            )
            .rect(
                self.config[&#34;panelWidth&#34;],
                self.config[&#34;DrillTemplateMarkThickness&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
            .moveTo(  # Bottom
                0,
                self.config[&#34;panelHeight&#34;] / 2
                - self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
            )
            .rect(
                self.config[&#34;panelWidth&#34;],
                self.config[&#34;DrillTemplateMarkThickness&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
            .moveTo(  # Left
                -self.config[&#34;panelWidth&#34;] / 2
                + self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
                0,
            )
            .rect(
                self.config[&#34;DrillTemplateMarkThickness&#34;],
                self.config[&#34;panelHeight&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
            .moveTo(  # Right
                self.config[&#34;panelWidth&#34;] / 2
                - self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
                0,
            )
            .rect(
                self.config[&#34;DrillTemplateMarkThickness&#34;],
                self.config[&#34;panelHeight&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
        )

    def markCross(self, x: float, y: float):
        &#34;&#34;&#34;Adds a mark on the drill template layer. At typical synth panel
        sizes, it will show up as a cross the perfect size for printing out and
        using as a drill template.

        x, y define the center of the mark as seen from the front.
        &#34;&#34;&#34;
        self.drillTemplate = (
            self.drillTemplate.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(
                self.config[&#34;DrillTemplateMarkLength&#34;],
                self.config[&#34;DrillTemplateMarkThickness&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
            .moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(
                self.config[&#34;DrillTemplateMarkThickness&#34;],
                self.config[&#34;DrillTemplateMarkLength&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
        )

    def markRect(self, x: float, y: float, width: float, height: float):
        &#34;&#34;&#34;Marks a rectangle on the drill template.

        x, y define the center.&#34;&#34;&#34;

        self.drillTemplate = (
            self.drillTemplate.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(width, height)
            .extrude(1)
            .moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(
                width - self.config[&#34;DrillTemplateMarkThickness&#34;] * 2,
                height - self.config[&#34;DrillTemplateMarkThickness&#34;] * 2,
            )
            .cutThruAll()
        )

    def markHole(self, x: float, y: float, diameter: float):
        &#34;&#34;&#34;Marks a circular hole on the drill template.

        x, y define the center.

        FIXME: Nasty implementation, and requires marking circles before crosses

        &#34;&#34;&#34;
        self.drillTemplate = (
            self.drillTemplate.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .circle(diameter / 2)
            .extrude(1)
            .moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .circle(diameter / 2 - self.config[&#34;DrillTemplateMarkThickness&#34;])
            .cutThruAll()
        )
        return

    #######################################################################
    ### Buttons and switches
    #######################################################################

    def cutArcadeButton30mm(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;arcade30mmButtonWithTolerance&#34;])

    def previewArcadeButton30mm(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 32.3, 3.4)
        self.previewCylinderOnFront(x, y, 24, 7)
        self.previewCylinderOnBack(x, y, 24, 24.4)
        self.previewCylinderOnBack(x, y, 34.8, 6.5)

    def markArcadeButton30mm(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;arcade30mmButtonWithTolerance&#34;])
        self.markCross(x, y)

    def addArcadeButton30mm(self, x: float, y: float):
        &#34;&#34;&#34;Should work with all major types of 30mm arcade buttons.

        30mm is the size of action buttons commonly seen in arcade cabinets.
        Smaller buttons like the start button are 24mm.

        Tested with the Sanwa OBSF-30 snap-in button.
        Sanwas have a hair trigger and a concave surface.

        Also tested with an unidentified screw-in type. The preview includes its retaining ring.

        Also tested with an unidentified Happ type.
        Happ buttons are concave are more commonly seen on American games.
        They are much deeper than on the preview.
        &#34;&#34;&#34;
        self.cutArcadeButton30mm(x, y)
        self.previewArcadeButton30mm(x, y)
        self.markArcadeButton30mm(x, y)

    def cutArcadeButton24mm(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;arcade24mmButtonWithTolerance&#34;])
        self.cutHole(
            x,
            y,
            self.config[&#34;arcade24mmButtonAdditionalClearanceDiameter&#34;],
            self.config[&#34;arcade24mmButtonAdditionalClearanceDepth&#34;],
        )

    def previewArcadeButton24mm(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 27, 3.4)
        self.previewCylinderOnFront(x, y, 22, 7)
        self.previewCylinderOnBack(x, y, 24, 24.4)
        self.previewCylinderOnBack(x, y, 28, 6)

    def markArcadeButton24mm(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;arcade24mmButtonWithTolerance&#34;])
        self.markCross(x, y)

    def addArcadeButton24mm(self, x: float, y: float):
        &#34;&#34;&#34;Should work with all major types of 24mm arcade buttons.

        24mm is the size of utility buttons (like the start button) commonly seen in arcade cabinets.
        Actual action buttons are 30mm.

        Uses the dimensions for the Sanwa OBSF-24 snap-in button.
        Sanwas have a hair trigger and a concave surface.

        Also tested with an unidentified screw-in type. The preview includes its retaining ring.
        &#34;&#34;&#34;
        self.cutArcadeButton24mm(x, y)
        self.previewArcadeButton24mm(x, y)
        self.markArcadeButton24mm(x, y)

    def cutMiniToggleSwitch(self, x: float, y: float, orientation: str = &#34;horizontal&#34;):
        if not self.config[&#34;panelRender&#34;]:
            return
        if orientation == &#34;horizontal&#34;:
            width = self.config[&#34;miniToggleSwitchWidthWithTolerance&#34;]
            length = self.config[&#34;miniToggleSwitchLengthWithTolerance&#34;]
        else:
            width = self.config[&#34;miniToggleSwitchLengthWithTolerance&#34;]
            length = self.config[&#34;miniToggleSwitchWidthWithTolerance&#34;]

        self.cutHole(x, y, self.config[&#34;miniToggleSwitchDiameterWithTolerance&#34;])
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(width, length)
            .cutBlind(-self.config[&#34;miniToggleSwitchNotchDepth&#34;])
        )

    def previewMiniToggleSwitch(
        self, x: float, y: float, orientation: str = &#34;horizontal&#34;
    ):
        if not self.config[&#34;previewRender&#34;]:
            return
        if orientation == &#34;horizontal&#34;:
            width = self.config[&#34;miniToggleSwitchWidth&#34;]
            length = self.config[&#34;miniToggleSwitchLength&#34;]
        else:
            width = self.config[&#34;miniToggleSwitchLength&#34;]
            length = self.config[&#34;miniToggleSwitchWidth&#34;]
        self.previewBoxOnBack(x, y, width, length, 13.6)
        self.previewCylinderOnFront(x, y, self.config[&#34;miniToggleSwitchDiameter&#34;], 19)

    def markMiniToggleSwitch(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;miniToggleSwitchDiameterWithTolerance&#34;])
        self.markCross(x, y)

    def addMiniToggleSwitch(self, x: float, y: float, orientation: str = &#34;horizontal&#34;):
        &#34;&#34;&#34;A mini toggle switch, with a retaining notch.

        This will fit the switches often sold as the &#34;MTS-100&#34; series by Aliexpress vendors that have only a single row of pins.

        It will not fit DPDT switches that have two rows of pins, those are bigger.

        orientation: &#34;horizontal&#34; (default) or &#34;vertical&#34;.
        &#34;&#34;&#34;
        self.cutMiniToggleSwitch(x, y, orientation)
        self.previewMiniToggleSwitch(x, y, orientation)
        self.markMiniToggleSwitch(x, y)

    #######################################################################
    ### Potentiometers, rotary encoders, sliders
    #######################################################################

    def cutPotentiometer(
        self,
        x: float,
        y: float,
        notchOrientation: str = &#34;all&#34;,
        rotaryEncoderNotch: bool = False,
    ):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;potentiometerHoleDiameterWithTolerance&#34;])
        # List the notches
        points = []  # default to &#34;none&#34; configuration
        if notchOrientation == &#34;top&#34; or notchOrientation == &#34;all&#34;:
            points.append((0, -self.config[&#34;potentiometerNotchDistanceFromCenter&#34;]))
        if notchOrientation == &#34;right&#34; or notchOrientation == &#34;all&#34;:
            points.append((self.config[&#34;potentiometerNotchDistanceFromCenter&#34;], 0))
        if notchOrientation == &#34;bottom&#34; or notchOrientation == &#34;all&#34;:
            points.append((0, self.config[&#34;potentiometerNotchDistanceFromCenter&#34;]))
        if notchOrientation == &#34;left&#34; or notchOrientation == &#34;all&#34;:
            points.append((-self.config[&#34;potentiometerNotchDistanceFromCenter&#34;], 0))
        # Cut the notches
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .pushPoints(points)
            .hole(
                self.config[&#34;potentiometerNotchDiameter&#34;],
                self.config[&#34;potentiometerNotchDepth&#34;],
            )
        )
        # Notch for the encoder
        if rotaryEncoderNotch:
            self.panel = (
                self.panel.faces(&#34;&gt;Z&#34;)
                .vertices(&#34;&lt;XY&#34;)
                .workplane(centerOption=&#34;CenterOfMass&#34;)
                .center(x, y)
                .rect(
                    self.config[&#34;rotaryEncoderWidthWithTolerance&#34;],
                    self.config[&#34;rotaryEncoderHeightWithTolerance&#34;],
                )
                .cutBlind(-self.config[&#34;rotaryEncoderNotchDepth&#34;])
            )

    def previewPotentiometer(self, x: float, y: float, lugsOrientation: str = &#34;all&#34;):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 6, 21)
        self.previewCylinderOnFront(x, y, 9.6, 1.6)
        self.previewCylinderOnBack(x, y, 16, 8)
        if lugsOrientation == &#34;all&#34; or lugsOrientation == &#34;bottom&#34;:
            self.previewBoxOnBack(x, y + 8, 15, 18, 2.4)
        if lugsOrientation == &#34;top&#34;:
            self.previewBoxOnBack(x, y - 8, 15, 18, 2.4)
        if lugsOrientation == &#34;left&#34;:
            self.previewBoxOnBack(x - 8, y, 18, 15, 2.4)
        if lugsOrientation == &#34;right&#34;:
            self.previewBoxOnBack(x + 8, y, 18, 15, 2.4)

    def markPotentiometer(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;potentiometerHoleDiameterWithTolerance&#34;])
        self.markCross(x, y)

    def addPotentiometer(
        self,
        x: float,
        y: float,
        notchOrientation: str = &#34;all&#34;,
        lugsOrientation: str = &#34;all&#34;,
        rotaryEncoderNotch: bool = False,
    ):
        &#34;&#34;&#34;Fits most types of panel-mount potentiometers with a 6mm shaft.

        There will be four notches around the hole, allowing you to catch the
        retaining tab of the potentiometer in the most convenient orientation
        possible.

        Common rotary encoders such as EC11 could use a thinner panel for the
        shaft to protrude sufficiently, in which case, set `rotaryEncoderNotch`
        to `True` to cut a rectangle in the back of the  panel.

        If you want a knob, add it separately with addKnob()

        The orientation parameters are seen from the front, and are:
        &#34;all&#34;, &#34;none&#34;, &#34;top&#34;, &#34;left&#34;, &#34;right&#34;, &#34;bottom&#34;.

        The retaining notches aren&#39;t always on the same side, depending on the
        type of potentiometer! If in doubt, just leave it to &#34;all&#34; to add 4 notches.

        The preview size for the lugs doesn&#39;t account for the possibility of bending them,
        so it might be safe to have this area overlap other stuff a little.
        &#34;&#34;&#34;
        self.cutPotentiometer(x, y, notchOrientation, rotaryEncoderNotch)
        self.previewPotentiometer(x, y, lugsOrientation)
        self.markPotentiometer(x, y)

    def previewKnob(self, x: float, y: float, diameter: float, depth: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, diameter, depth + 5)

    def addKnob(self, x: float, y: float, diameter: float, depth: float):
        &#34;&#34;&#34;Adds a knob for preview only. Place it at the same location as
        potentiometers and rotary encoders!

        Since there is a lot of variation in knob sizes, and sometimes the
        shaft is left exposed without a knob, it&#39;s not added automatically.&#34;&#34;&#34;
        self.previewKnob(x, y, diameter, depth)

    def cutSlider(
        self,
        x: float,
        y: float,
        sliderWidth: float,
        sliderHeight: float,
        slotWidth: float,
        slotHeight: float,
    ):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(
                sliderWidth,
                sliderHeight,
            )
            .cutBlind(-self.config[&#34;sliderNotchDepth&#34;])
        )
        self.cutRect(x, y, slotWidth, slotHeight, 0, True)

    def previewSlider(
        self, x: float, y: float, sliderWidth: float, sliderHeight: float
    ):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 15, 10)
        self.previewBoxOnBack(x, y, sliderWidth, sliderHeight, 22)

    def markSlider(
        self,
        x: float,
        y: float,
        sliderWidth: float,
        sliderHeight: float,
        slotWidth: float,
        slotHeight: float,
    ):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markRect(x, y, sliderWidth, sliderHeight)
        self.markRect(x, y, slotWidth, slotHeight)

    def addSlider(
        self,
        x: float,
        y: float,
        sliderWidth: float,
        sliderHeight: float,
        slotWidth: float,
        slotHeight: float,
    ):
        &#34;&#34;&#34;For slide potentiomenters. Multiple sizes are common, so you have to
        specify yours.

        No special provision are made to hold them in place, it&#39;s assumed you
        have a PCB or are will add some glue or something similarly nasty.

        x, y: center
        &#34;&#34;&#34;
        self.cutSlider(x, y, sliderWidth, sliderHeight, slotWidth, slotHeight)
        self.previewSlider(x, y, sliderWidth, sliderHeight)
        self.markSlider(x, y, sliderWidth, sliderHeight, slotWidth, slotHeight)

    #######################################################################
    ### Jacks &amp; Sockets
    #######################################################################

    def cutBigJack(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;bigJackDiameterWithTolerance&#34;])
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(
                self.config[&#34;bigJackWidthWithTolerance&#34;],
                self.config[&#34;bigJackHeightWithTolerance&#34;],
            )
            .cutBlind(-self.config[&#34;bigJackNotchDepth&#34;])
        )

    def previewBigJack(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 8.5, 7)
        self.previewCylinderOnFront(x, y, 12.6, 2.2)
        self.previewBoxOnBack(x, y, 16, 16, 27)

    def markBigJack(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;bigJackDiameterWithTolerance&#34;])
        self.markCross(x, y)

    def addBigJack(self, x: float, y: float):
        &#34;&#34;&#34;This fits panel mount 6.35mm jacks with a rectangular base, as used
        in Kosmo builds.

        There is a retaining notch the size of the base to help keep it in place.
        &#34;&#34;&#34;
        self.cutBigJack(x, y)
        self.previewBigJack(x, y)
        self.markBigJack(x, y)

    def cutMiniJack(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;miniJackDiameterWithTolerance&#34;])
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(
                self.config[&#34;miniJackSizeWithTolerance&#34;],
                self.config[&#34;miniJackSizeWithTolerance&#34;],
            )
            .cutBlind(-self.config[&#34;miniJackNotchDepth&#34;])
        )

    def previewMiniJack(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 6, 5.5)
        self.previewCylinderOnFront(x, y, 8, 2.2)
        self.previewBoxOnBack(x, y, 9, 10.5, 12.5)

    def markMiniJack(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;miniJackDiameterWithTolerance&#34;])
        self.markCross(x, y)

    def addMiniJack(self, x: float, y: float):
        &#34;&#34;&#34;This fits 3.5mm PJ398SM &#34;Thonkiconn&#34; 3.5mm jacks and similar.

        There is a retaining notch the size of the base to help keep it in place.
        &#34;&#34;&#34;
        self.cutMiniJack(x, y)
        self.previewMiniJack(x, y)
        self.markMiniJack(x, y)

    def cutMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;midiSocketDiameterWithTolerance&#34;])
        if screws == &#34;horizontal&#34;:
            self.cutHole(
                x - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                y,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.cutHole(
                x + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                y,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
        if screws == &#34;vertical&#34;:
            self.cutHole(
                x,
                y - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.cutHole(
                x,
                y + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )

    def previewMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnBack(x, y, 14, 16)
        if screws == &#34;horizontal&#34;:
            self.previewBoxOnFront(x, y, 28, 19, 1)
        if screws == &#34;vertical&#34;:
            self.previewBoxOnFront(x, y, 19, 28, 1)

    def markMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;midiSocketDiameterWithTolerance&#34;])
        self.markCross(x, y)
        if screws == &#34;horizontal&#34;:
            self.markHole(
                x - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                y,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.markHole(
                x + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                y,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.markCross(x - self.config[&#34;midiSocketScrewDistance&#34;] / 2, y)
            self.markCross(x + self.config[&#34;midiSocketScrewDistance&#34;] / 2, y)
        if screws == &#34;vertical&#34;:
            self.markHole(
                x,
                y - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.markHole(
                x,
                y + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.markCross(x, y - self.config[&#34;midiSocketScrewDistance&#34;] / 2)
            self.markCross(x, y + self.config[&#34;midiSocketScrewDistance&#34;] / 2)

    def addMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
        &#34;&#34;&#34;Adds a panel mount female DIN socket.

        It fits the aluminum sockets that have two M3 screws on each side.

        screws: &#34;horizontal&#34;, &#34;vertical&#34;, or &#34;none&#34;
        &#34;&#34;&#34;
        self.cutMidiSocket(x, y, screws)
        self.previewMidiSocket(x, y, screws)
        self.markMidiSocket(x, y, screws)

    #######################################################################
    ### Blinkenlichten
    #######################################################################

    def cutLed5mm(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;5mmLedWithTolerance&#34;])

    def previewLed5mm(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 4.7, 3)
        self.previewBoxOnBack(x, y, 4, 1, 17)

    def markLed5mm(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;5mmLedWithTolerance&#34;])
        self.markCross(x, y)

    def addLed5mm(self, x: float, y: float):
        &#34;&#34;&#34;Creates a hole for a 5mm LED protruding from the hole.

        There is no mechanism to hold it in place, but hot glue will do the trick.
        &#34;&#34;&#34;
        self.cutLed5mm(x, y)
        self.previewLed5mm(x, y)
        self.markLed5mm(x, y)

    def cutLed3mm(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;3mmLedWithTolerance&#34;])

    def previewLed3mm(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 2.8, 1)
        self.previewBoxOnBack(x, y, 2.7, 1, 17)

    def markLed3mm(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;3mmLedWithTolerance&#34;])
        self.markCross(x, y)

    def addLed3mm(self, x: float, y: float):
        &#34;&#34;&#34;Creates a hole for a 3mm LED fitting inside the hole.
        On default settings, it will not protrude past the hole, and might
        diffuse a bit of light in the surrounding plastic.

        There is no mechanism to hold it in place, but hot glue will do the trick.
        &#34;&#34;&#34;
        self.cutLed3mm(x, y)
        self.previewLed3mm(x, y)
        self.markLed3mm(x, y)

    def cutDisplayWindow(
        self,
        x: float,
        y: float,
        windowWidth: float = 30,
        windowHeight: float = 15,
        windowHorizontalOffset: float = 0,
        windowVerticalOffset: float = -5,
        screwsHorizontalDistance: float = 40,
        screwsVerticalDistance: float = 40,
        addScrews: bool = True,
    ):
        # FIXME: This is the nastiest way possible to implement a fillet
        # but the only one I could figure out.

        cutout = (
            cq.Workplane(&#34;XY&#34;)
            .box(
                windowWidth + self.config[&#34;panelThickness&#34;],
                windowHeight + self.config[&#34;panelThickness&#34;],
                self.config[&#34;panelThickness&#34;],
            )
            .edges(&#34;&gt;Z&#34;)
            .fillet(self.config[&#34;panelThickness&#34;] * 0.99)
            .translate(
                (
                    -self.config[&#34;panelWidth&#34;] / 2 + x + windowHorizontalOffset,
                    -self.config[&#34;panelHeight&#34;] / 2 + y + windowVerticalOffset,
                    0,
                )
            )
        )
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .cut(cutout)
        )

        # Next, the actual cutout
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x + windowHorizontalOffset, y + windowVerticalOffset)
            .rect(windowWidth, windowHeight)
            .cutThruAll()
        )

        # Now, the screws
        if addScrews:
            self.panel = (
                self.panel.faces(&#34;&gt;Z&#34;)
                .vertices(&#34;&lt;XY&#34;)
                .workplane(centerOption=&#34;CenterOfMass&#34;)
                .center(x, y)
                .rect(
                    screwsHorizontalDistance,
                    screwsVerticalDistance,
                    forConstruction=True,
                )
                .vertices()
                .circle(self.config[&#34;m2DiameterWithTolerance&#34;] / 2)
                .cutThruAll()
            )

    def markDisplayWindow(
        self,
        x: float,
        y: float,
        windowWidth: float = 30,
        windowHeight: float = 15,
        windowHorizontalOffset: float = 0,
        windowVerticalOffset: float = -5,
        screwsHorizontalDistance: float = 40,
        screwsVerticalDistance: float = 40,
        addScrews: bool = True,
    ):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markRect(
            x + windowHorizontalOffset,
            y + windowVerticalOffset,
            windowWidth,
            windowHeight,
        )
        if addScrews:
            self.markHole(
                x - screwsHorizontalDistance / 2,
                y - screwsVerticalDistance / 2,
                self.config[&#34;m2DiameterWithTolerance&#34;],
            )
            self.markHole(
                x + screwsHorizontalDistance / 2,
                y - screwsVerticalDistance / 2,
                self.config[&#34;m2DiameterWithTolerance&#34;],
            )
            self.markHole(
                x - screwsHorizontalDistance / 2,
                y + screwsVerticalDistance / 2,
                self.config[&#34;m2DiameterWithTolerance&#34;],
            )
            self.markHole(
                x + screwsHorizontalDistance / 2,
                y + screwsVerticalDistance / 2,
                self.config[&#34;m2DiameterWithTolerance&#34;],
            )
            self.markCross(
                x - screwsHorizontalDistance / 2,
                y - screwsVerticalDistance / 2,
            )
            self.markCross(
                x + screwsHorizontalDistance / 2,
                y - screwsVerticalDistance / 2,
            )
            self.markCross(
                x - screwsHorizontalDistance / 2,
                y + screwsVerticalDistance / 2,
            )
            self.markCross(
                x + screwsHorizontalDistance / 2,
                y + screwsVerticalDistance / 2,
            )

    def addDisplayWindow(
        self,
        x: float,
        y: float,
        windowWidth: float = 30,
        windowHeight: float = 15,
        windowHorizontalOffset: float = 0,
        windowVerticalOffset: float = -5,
        screwsHorizontalDistance: float = 40,
        screwsVerticalDistance: float = 40,
        addScrews: bool = True,
    ):
        &#34;&#34;&#34;Creates a window for a rectangular display mounted with four screws in the corner.

        Every single display available has different dimensions, especially the cheapo OLEDs
        from Aliexpress. Even when the display size is the same, various boards differ by
        a few millimeters.

        The defaults offered are for a non-existent model, for preview purposes.
        Provide your own measurements instead!

        There is no preview widget for this footprint.
        &#34;&#34;&#34;
        self.cutDisplayWindow(
            x,
            y,
            windowWidth,
            windowHeight,
            windowHorizontalOffset,
            windowVerticalOffset,
            screwsHorizontalDistance,
            screwsVerticalDistance,
            addScrews,
        )

        self.markDisplayWindow(
            x,
            y,
            windowWidth,
            windowHeight,
            windowHorizontalOffset,
            windowVerticalOffset,
            screwsHorizontalDistance,
            screwsVerticalDistance,
            addScrews,
        )

    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################


#######################################################################
### Helpers
#######################################################################


def hp(hp: float):
    &#34;&#34;&#34;Converts Eurorack Horizontal Pitch to millimeters (1hp = 0.2in = 5.08mm).
    Useful to align things to the grid.&#34;&#34;&#34;
    return hp * 5.08


def khp(khp: float):
    &#34;&#34;&#34;Converts khp (Kosmo HP) to millimeters (1khp = 25mm).
    Useful to align things to the the custom kcol / krow grid.&#34;&#34;&#34;
    return khp * 25


def kcol(kcol: float):
    &#34;&#34;&#34;Custom Kosmo grid system: each kcol is at the center of a 25mm section&#34;&#34;&#34;
    return (kcol - 1) * 25 + 12.5


def krow(krow: float):
    &#34;&#34;&#34;Custom Kosmo grid system: each krow is 25mm, first starts 25mm from top&#34;&#34;&#34;
    return (krow) * 25


# To generate API reference: `pdoc --html --force synthprinter.py -o ./`</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="synthprinter.hp"><code class="name flex">
<span>def <span class="ident">hp</span></span>(<span>hp: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts Eurorack Horizontal Pitch to millimeters (1hp = 0.2in = 5.08mm).
Useful to align things to the grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hp(hp: float):
    &#34;&#34;&#34;Converts Eurorack Horizontal Pitch to millimeters (1hp = 0.2in = 5.08mm).
    Useful to align things to the grid.&#34;&#34;&#34;
    return hp * 5.08</code></pre>
</details>
</dd>
<dt id="synthprinter.kcol"><code class="name flex">
<span>def <span class="ident">kcol</span></span>(<span>kcol: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom Kosmo grid system: each kcol is at the center of a 25mm section</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kcol(kcol: float):
    &#34;&#34;&#34;Custom Kosmo grid system: each kcol is at the center of a 25mm section&#34;&#34;&#34;
    return (kcol - 1) * 25 + 12.5</code></pre>
</details>
</dd>
<dt id="synthprinter.khp"><code class="name flex">
<span>def <span class="ident">khp</span></span>(<span>khp: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts khp (Kosmo HP) to millimeters (1khp = 25mm).
Useful to align things to the the custom kcol / krow grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def khp(khp: float):
    &#34;&#34;&#34;Converts khp (Kosmo HP) to millimeters (1khp = 25mm).
    Useful to align things to the the custom kcol / krow grid.&#34;&#34;&#34;
    return khp * 25</code></pre>
</details>
</dd>
<dt id="synthprinter.krow"><code class="name flex">
<span>def <span class="ident">krow</span></span>(<span>krow: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom Kosmo grid system: each krow is 25mm, first starts 25mm from top</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def krow(krow: float):
    &#34;&#34;&#34;Custom Kosmo grid system: each krow is 25mm, first starts 25mm from top&#34;&#34;&#34;
    return (krow) * 25</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="synthprinter.SynthPrinter"><code class="flex name class">
<span>class <span class="ident">SynthPrinter</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Each SynthPrinter object corresponds to a panel. You must add one, and
only one panel, before performing operations on it.</p>
<p>Once you're done placing elements, you must call <code>render()</code> before
exporting your work, to post-process things correctly.
Elements will be aligned and oriented wrong if you skip this call.</p>
<p>The naming convention of methods is as follows:</p>
<ul>
<li><code>addX()</code>: calls methods such as <code>cutX()</code>, <code>previewX()</code>, etc, operating on multiple
layers. Skips drawing to disabled layers for performance, so disable unnecessary
layers in the constructor while making your layout.
In most cases, you want to call those methods instead of making the individual calls
bundled in the <code>addX()</code> methods.</li>
<li><code>cutX()</code>: makes a hole for X on the <strong>panel</strong> layer</li>
<li><code>markX()</code>: draws marks for X on the <strong>drillTemplate</strong> layer.
<em>[Exporting a drill template is a WIP, it still takes a bit of tinkering to
make the PDF the proper size]</em></li>
<li><code>previewX()</code>: draws boxes and cylinders to preview the size of footprints
on the <strong>preview</strong> layer</li>
<li><code>embossX()</code>: creates an element on the <strong>emboss</strong> layer. You can only 3D print
embossings if you orient your panel with the back as the first layer.
<em>[Not implemented yet]</em></li>
<li><code>engraveX()</code>: carves an engraving that does not cut all the way through the
<strong>panel</strong> layer</li>
<li><code>supportX()</code>: creates an element on the <strong>supports</strong> layer, used to strenghten
panels and hold in place PCBs. You can only 3D print supports if you orient
your panel with the front as the first layer.</li>
</ul>
<p>Be sure to take a look at the bundled examples!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SynthPrinter:
    &#34;&#34;&#34;Each SynthPrinter object corresponds to a panel. You must add one, and
    only one panel, before performing operations on it.

    Once you&#39;re done placing elements, you must call `render()` before
    exporting your work, to post-process things correctly.
    Elements will be aligned and oriented wrong if you skip this call.

    The naming convention of methods is as follows:

    - `addX()`: calls methods such as `cutX()`, `previewX()`, etc, operating on multiple
    layers. Skips drawing to disabled layers for performance, so disable unnecessary
    layers in the constructor while making your layout.
    In most cases, you want to call those methods instead of making the individual calls
    bundled in the `addX()` methods.
    - `cutX()`: makes a hole for X on the **panel** layer
    - `markX()`: draws marks for X on the **drillTemplate** layer.
    _[Exporting a drill template is a WIP, it still takes a bit of tinkering to
    make the PDF the proper size]_
    - `previewX()`: draws boxes and cylinders to preview the size of footprints
    on the **preview** layer
    - `embossX()`: creates an element on the **emboss** layer. You can only 3D print
    embossings if you orient your panel with the back as the first layer.
    _[Not implemented yet]_
    - `engraveX()`: carves an engraving that does not cut all the way through the
    **panel** layer
    - `supportX()`: creates an element on the **supports** layer, used to strenghten
    panels and hold in place PCBs. You can only 3D print supports if you orient
    your panel with the front as the first layer.

    Be sure to take a look at the bundled examples!
    &#34;&#34;&#34;

    defaultConfig = {
        ###########################################################
        # You can override any of these settings from the defaultConfig by
        # passing them as a parameter to the constructor.
        #
        # Preview objects have their sizes hardcoded to keep
        # the size of this config in check.
        #
        ###########################################################
        ### Common Dimensions
        ###########################################################
        &#34;tolerance&#34;: 0.4,
        &#34;panelWidth&#34;: 100.0,
        &#34;panelHeight&#34;: 100.0,
        &#34;panelThickness&#34;: 4.0,
        &#34;hp&#34;: 5.08,  # 0.2 inches
        &#34;khp&#34;: 25,  # Kosmo horizontal pitch
        # default depth of 1.02mm, to ensure that at 0.20mm print settings,
        # it hollows out 5 layers instead of 4. This helps making the notches
        # better at keeping things in place.
        &#34;retainingNotchDepth&#34;: lambda config: config[&#34;panelThickness&#34;] / 3.9,
        ###########################################################
        ### Visualization in CQ Editor
        ###########################################################
        &#34;panelRender&#34;: True,
        &#34;supportsRender&#34;: True,
        &#34;embossRender&#34;: True,
        &#34;previewRender&#34;: True,  # Disable to improve render performance
        &#34;drillTemplateRender&#34;: False,
        &#34;panelShowOptions&#34;: {&#34;alpha&#34;: 0.2, &#34;color&#34;: (0, 180, 230)},
        &#34;supportsShowOptions&#34;: {&#34;alpha&#34;: 0.1, &#34;color&#34;: (180, 230, 0)},
        &#34;embossShowOptions&#34;: {&#34;alpha&#34;: 0.2, &#34;color&#34;: (50, 180, 230)},
        &#34;previewShowOptions&#34;: {&#34;alpha&#34;: 0.65, &#34;color&#34;: (100, 30, 30)},
        &#34;drillTemplateShowOptions&#34;: {&#34;alpha&#34;: 0.1, &#34;color&#34;: (20, 20, 20)},
        ###########################################################
        ### Screws
        ###########################################################
        ###### M3
        &#34;m3Diameter&#34;: 3.0,
        &#34;m3DiameterWithTolerance&#34;: lambda config: config[&#34;m3Diameter&#34;]
        + config[&#34;tolerance&#34;],
        &#34;m3screwSlotWidth&#34;: lambda config: config[&#34;m3DiameterWithTolerance&#34;] * 2.5,
        &#34;m3screwSlotHeight&#34;: lambda config: config[&#34;m3DiameterWithTolerance&#34;],
        &#34;m3screwSlotDistanceFromTop&#34;: 3.0,
        &#34;m3screwSlotDistanceFromBottom&#34;: 3.0,
        &#34;m3screwSlotDistanceFromSide&#34;: lambda config: config[&#34;m3DiameterWithTolerance&#34;]
        * 1.5,
        ###### M2
        &#34;m2Diameter&#34;: 2.0,
        &#34;m2DiameterWithTolerance&#34;: lambda config: config[&#34;m2Diameter&#34;]
        + config[&#34;tolerance&#34;] * 1.5,  # More expansion with small screws
        ###########################################################
        ### Panels
        ###########################################################
        &#34;eurorackHeight&#34;: 128.5,  # Modules are smaller than the full 3U
        &#34;eurorackWidthTolerance&#34;: lambda config: config[&#34;tolerance&#34;],
        &#34;1UIJHeight&#34;: 39.65,  # Itellijel 1U - for our purposes, normal Euro but 1U tall
        &#34;1UIJWidthTolerance&#34;: lambda config: config[&#34;tolerance&#34;],
        &#34;kosmoHeight&#34;: 200.0,
        &#34;kosmoWidthTolerance&#34;: 0,  # Kosmo needs no additional tolerance as HP rails are larger
        &#34;panelWidthTolerance&#34;: 0,  # Set when adding the panel
        ###########################################################
        ### Panel engravings
        ###########################################################
        &#34;panelEngravingDepth&#34;: lambda config: config[&#34;panelThickness&#34;] / 3,
        ###########################################################
        ### Rails &amp; Cradles
        ###########################################################
        &#34;railsFrontRecess&#34;: 2,  # 1.6 PCB + junk leftover from supports
        &#34;railsSupportDepthBack&#34;: 4.0,  # How much to protrude behind panel, not full depth
        &#34;railsHeight&#34;: 8,
        &#34;railsScrewDiameter&#34;: lambda config: config[
            &#34;m3Diameter&#34;
        ],  # Not adding the tolerance holds better
        &#34;cradleTolerance&#34;: lambda config: config[&#34;tolerance&#34;],
        ###########################################################
        ### Buttons and switches
        ###########################################################
        ###### Arcade
        # Sanwas have little clips making them require more tolerance
        # and the 24mm one require a thinner panel than the default
        # to snap in properly
        &#34;arcade24mmButton&#34;: 24,
        &#34;arcade24mmButtonWithTolerance&#34;: lambda config: config[&#34;arcade24mmButton&#34;]
        + config[&#34;tolerance&#34;] * 1.4,
        &#34;arcade24mmButtonAdditionalClearanceDiameter&#34;: 27,
        &#34;arcade24mmButtonAdditionalClearanceDepth&#34;: lambda config: config[
            &#34;retainingNotchDepth&#34;
        ],
        &#34;arcade30mmButton&#34;: 30,
        &#34;arcade30mmButtonWithTolerance&#34;: lambda config: config[&#34;arcade30mmButton&#34;]
        + config[&#34;tolerance&#34;] * 1.4,
        ###### Mini Toggle Switches
        &#34;miniToggleSwitchWidth&#34;: 13.2,
        &#34;miniToggleSwitchLength&#34;: 7.9,
        &#34;miniToggleSwitchDiameter&#34;: 6,
        &#34;miniToggleSwitchWidthWithTolerance&#34;: lambda config: config[
            &#34;miniToggleSwitchWidth&#34;
        ]
        + config[&#34;tolerance&#34;],
        &#34;miniToggleSwitchLengthWithTolerance&#34;: lambda config: config[
            &#34;miniToggleSwitchLength&#34;
        ]
        + config[&#34;tolerance&#34;],
        &#34;miniToggleSwitchDiameterWithTolerance&#34;: lambda config: config[
            &#34;miniToggleSwitchDiameter&#34;
        ]
        + config[&#34;tolerance&#34;],
        &#34;miniToggleSwitchNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        ###########################################################
        ### Potentiometers and rotary encoders
        ###########################################################
        ###### Pots
        &#34;potentiometerHoleDiameter&#34;: 7,
        &#34;potentiometerHoleDiameterWithTolerance&#34;: lambda config: config[
            &#34;potentiometerHoleDiameter&#34;
        ]
        + config[&#34;tolerance&#34;],
        &#34;potentiometerNotchDistanceFromCenter&#34;: 6.9,
        &#34;potentiometerNotchDiameter&#34;: 3.9,
        &#34;potentiometerNotchDepth&#34;: lambda config: config[&#34;panelThickness&#34;] / 1.5,
        &#34;rotaryEncoderWidth&#34;: 14,
        &#34;rotaryEncoderWidthWithTolerance&#34;: lambda config: config[&#34;rotaryEncoderWidth&#34;]
        + config[&#34;tolerance&#34;],
        &#34;rotaryEncoderHeight&#34;: 12,
        &#34;rotaryEncoderHeightWithTolerance&#34;: lambda config: config[&#34;rotaryEncoderHeight&#34;]
        + config[&#34;tolerance&#34;],
        &#34;rotaryEncoderNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        &#34;sliderNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        ###########################################################
        ### Jacks &amp; Sockets
        ###########################################################
        ###### Big
        &#34;bigJackDiameter&#34;: 9,
        &#34;bigJackDiameterWithTolerance&#34;: lambda config: config[&#34;bigJackDiameter&#34;]
        + config[&#34;tolerance&#34;],
        &#34;bigJackWidth&#34;: 16,
        &#34;bigJackHeight&#34;: lambda config: config[&#34;bigJackWidth&#34;],
        &#34;bigJackWidthWithTolerance&#34;: lambda config: config[&#34;bigJackWidth&#34;]
        + config[&#34;tolerance&#34;],
        &#34;bigJackHeightWithTolerance&#34;: lambda config: config[&#34;bigJackHeight&#34;]
        + config[&#34;tolerance&#34;],
        &#34;bigJackNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        ###### Mini
        &#34;miniJackDiameter&#34;: 6,
        &#34;miniJackDiameterWithTolerance&#34;: lambda config: config[&#34;miniJackDiameter&#34;]
        + config[&#34;tolerance&#34;],
        &#34;miniJackSize&#34;: 9.5,
        &#34;miniJackSizeWithTolerance&#34;: lambda config: config[&#34;miniJackSize&#34;]
        + config[&#34;tolerance&#34;] * 2,
        &#34;miniJackNotchDepth&#34;: lambda config: config[&#34;retainingNotchDepth&#34;],
        ###### MIDI
        &#34;midiSocketDiameter&#34;: 15,
        &#34;midiSocketDiameterWithTolerance&#34;: lambda config: config[&#34;midiSocketDiameter&#34;]
        + config[&#34;tolerance&#34;] * 2,
        &#34;midiSocketScrewDistance&#34;: 21.6,
        &#34;midiSocketScrewDiameterWithTolerance&#34;: lambda config: config[
            &#34;m3DiameterWithTolerance&#34;
        ],
        ###########################################################
        ### Blinkenlichten
        ###########################################################
        &#34;5mmLed&#34;: 4.9,
        &#34;5mmLedWithTolerance&#34;: lambda config: config[&#34;5mmLed&#34;] + config[&#34;tolerance&#34;],
        &#34;3mmLed&#34;: 2.9,
        &#34;3mmLedWithTolerance&#34;: lambda config: config[&#34;3mmLed&#34;]
        + config[&#34;tolerance&#34;] * 1.5,
        ###########################################################
        ### Drill Template
        ###########################################################
        &#34;DrillTemplateMarkLength&#34;: 10,
        &#34;DrillTemplateMarkThickness&#34;: 0.2,
        &#34;DrillTemplateDistance&#34;: -80,
    }
    &#34;&#34;&#34;
    You can override any of the defaultConfig settings by passing them as a
    parameter to the constructor. Look at the code for the full list of
    settings. Some are dynamically calculated from other settings, 
    in particular, the tolerances of most elements are expressed as a
    multiplier of the main tolerance value.

    For example, to replace the main tolerance value of 0.4mm, create a
    new object as follows:

        sp = SynthPrinter(
            tolerance=0.6,
        )

    defaultConfig values are mostly dimensions that have been tested to
    work well with 3D printing. You are encouraged to try out the defaults 
    first. But with a different process than FDM 3D printing, you will want to
    make your own configuration profile.&#34;&#34;&#34;

    def __init__(self, **kwargs):
        self.config = self.defaultConfig.copy()

        # override defaults
        for key, value in kwargs.items():
            if key in self.config:
                self.config[key] = value

        # call lambdas
        for key, value in self.config.items():
            if callable(value):
                self.config[key] = value(self.config)

        # Create layers
        self.panel = cq.Workplane(&#34;XY&#34;)
        self.preview = cq.Workplane(&#34;XY&#34;)
        self.emboss = cq.Workplane(&#34;XY&#34;)
        self.supports = cq.Workplane(&#34;XY&#34;)
        self.drillTemplate = cq.Workplane(&#34;XY&#34;)

        self.panelAdded = False  # We can only have one or horrible things happen

    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################

    #######################################################################
    ### Rendering &amp; Export
    #######################################################################

    def render(self, show_object=False):
        &#34;&#34;&#34;You must call this before displaying or exporting your panel
        to post-process it properly.

        If you give it the show_object function from Cq Editor as an
        argument, it will also display the object. When using Synth Printer
        from a different environment, just call without any argument.
        &#34;&#34;&#34;
        # Shave off the sides of the panel if needed
        self.cutPanelWidthTolerance()
        # Move the supports where they belong
        self.supports = self.supports.translate(
            (0, 0, self.config[&#34;panelThickness&#34;] / 2)
        )
        # Move the drill template above the panel
        self.drillTemplate = self.drillTemplate.translate(
            (0, 0, self.config[&#34;DrillTemplateDistance&#34;])
        )
        # Rotate the layers for viewing
        self.panel = self.panel.rotate((0, 0, 0), (1, 0, 0), 180)
        self.preview = self.preview.rotate((0, 0, 0), (1, 0, 0), 180)
        self.emboss = self.emboss.rotate((0, 0, 0), (1, 0, 0), 180)
        self.supports = self.supports.rotate((0, 0, 0), (1, 0, 0), 180)
        self.drillTemplate = self.drillTemplate.rotate((0, 0, 0), (1, 0, 0), 180)
        # Display the layers if we&#39;re in CQ Editor
        if show_object and self.config[&#34;panelRender&#34;]:
            show_object(
                self.panel,
                name=&#34;panel&#34;,
                options=self.config[&#34;panelShowOptions&#34;],
            )
        if show_object and self.config[&#34;supportsRender&#34;]:
            show_object(
                self.supports,
                name=&#34;supports&#34;,
                options=self.config[&#34;supportsShowOptions&#34;],
            )
        if show_object and self.config[&#34;embossRender&#34;]:
            show_object(
                self.emboss,
                name=&#34;emboss&#34;,
                options=self.config[&#34;embossShowOptions&#34;],
            )
        if show_object and self.config[&#34;previewRender&#34;]:
            show_object(
                self.preview,
                name=&#34;preview&#34;,
                options=self.config[&#34;previewShowOptions&#34;],
            )
        if show_object and self.config[&#34;drillTemplateRender&#34;]:
            show_object(
                self.drillTemplate,
                name=&#34;drillTemplate&#34;,
                options=self.config[&#34;drillTemplateShowOptions&#34;],
            )

    def exportDrillTemplate(self, filename: str = &#34;DrillTemplate.svg&#34;):
        &#34;&#34;&#34;Exports the drill template as a SVG file.

        Before you print it, crop and scale it up or down in image editing
        software to match the size of one side!

        TODO: Make it the perfect size out of the box.

        You must activate the layer in the constructor first! Otherwise,
        drill marks are not rendered, for performance.&#34;&#34;&#34;
        cq.exporters.export(
            self.drillTemplate,
            filename,
            opt={
                &#34;width&#34;: 2000,
                &#34;height&#34;: 2000,
                &#34;marginLeft&#34;: 0,
                &#34;marginTop&#34;: 0,
                &#34;showAxes&#34;: False,
                &#34;projectionDir&#34;: (0.0, 0.0, 1.0),
                &#34;strokeWidth&#34;: 0.25,
                &#34;strokeColor&#34;: (255, 0, 0),
                &#34;hiddenColor&#34;: (0, 0, 255),
                &#34;showHidden&#34;: False,
            },
        )

    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################

    #######################################################################
    ### Basic operations
    #######################################################################

    def cutHole(self, x: float, y: float, diameter: float, depth: float = None):
        &#34;&#34;&#34;Makes a circular hole, default depth is through the entire panel

        x, y define the center.&#34;&#34;&#34;
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .hole(diameter, depth)
        )

    def cutRect(
        self,
        x: float,
        y: float,
        width: float,
        height: float,
        depth: float = 0,
        centered: bool = True,
    ):
        &#34;&#34;&#34;Cuts a rectangular shape through the panel.

        x, y define the center

        `depth = 0` cuts through all.
        &#34;&#34;&#34;

        if depth == 0:
            depth = self.config[&#34;panelThickness&#34;]

        cutout = cq.Workplane(&#34;XY&#34;).box(width, height, depth)

        if centered:
            cutout = cutout.translate(
                (
                    -self.config[&#34;panelWidth&#34;] / 2 + x,
                    -self.config[&#34;panelHeight&#34;] / 2 + y,
                    0,
                )
            )
        else:
            cutout = cutout.translate(
                (
                    -self.config[&#34;panelWidth&#34;] / 2 + x + width / 2,
                    -self.config[&#34;panelHeight&#34;] / 2 + y + height / 2,
                    0,
                )
            )

        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .cut(cutout)
        )

    # TODO: Top-left support!
    def previewCylinderOnBack(self, x: float, y: float, diameter: float, depth: float):
        &#34;&#34;&#34;Adds a cylinder for preview on the back of the panel.
        It will be deeper by half the panel thickness.

        x, y define the center.&#34;&#34;&#34;
        self.preview = (
            self.preview.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .circle(diameter / 2)
            .extrude(depth + self.config[&#34;panelThickness&#34;] / 2)
        )

    def previewCylinderOnFront(self, x: float, y: float, diameter: float, depth: float):
        &#34;&#34;&#34;Adds a cylinder for preview on the front of the panel.
        It will be deeper by half the panel thickness.

        x, y define the center.&#34;&#34;&#34;
        self.preview = (
            self.preview.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .circle(diameter / 2)
            .extrude(-depth - self.config[&#34;panelThickness&#34;] / 2)
        )

    def previewBoxOnBack(
        self, x: float, y: float, width: float, height: float, depth: float
    ):
        &#34;&#34;&#34;Adds a box for preview on the back of the panel.
        It will be deeper by half the panel thickness.

        x, y define the center.&#34;&#34;&#34;
        self.preview = (
            self.preview.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(width, height)
            .extrude(depth + self.config[&#34;panelThickness&#34;] / 2)
        )

    def previewBoxOnFront(
        self, x: float, y: float, width: float, height: float, depth: float
    ):
        &#34;&#34;&#34;Adds a box for preview on the front of the panel.
        It will be deeper by half the panel thickness.

        x, y define the center.
        &#34;&#34;&#34;
        self.preview = (
            self.preview.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(width, height)
            .extrude(-depth - self.config[&#34;panelThickness&#34;] / 2)
        )

    #######################################################################
    ### Panels
    #######################################################################

    def addPanel(
        self,
        width: float,
        height: float,
        screwSlots: str = &#34;auto&#34;,
    ):
        &#34;&#34;&#34;Adds a rectangular panel of arbitrary dimensions.
        You can only add one.

        Screw slots in the corners provide better tolerances than holes
        in a DIY printed system. If the panel is too small for four slots,
        there will be only two by default.


        TODO: Add Slots to the drill template


        screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
        &#34;&#34;&#34;

        if self.panelAdded == True:
            raise Warning(&#34;Only one panel can be added&#34;)
        else:
            self.panelAdded = True

        self.config[&#34;panelWidth&#34;] = width
        self.config[&#34;panelHeight&#34;] = height

        # Make the main panel shape
        self.panel = self.panel.box(
            self.config[&#34;panelWidth&#34;],
            self.config[&#34;panelHeight&#34;],
            self.config[&#34;panelThickness&#34;],
        )

        # Initialize the drill template
        self.markOutline()

        # Do we add screw slots?
        # default to &#34;none&#34; configuration
        screwSlotTopLeft = False
        screwSlotTopCenter = False
        screwSlotTopRight = False
        screwSlotBottomLeft = False
        screwSlotBottomCenter = False
        screwSlotBottomRight = False
        if (  # If too small for 4 slots
            self.config[&#34;m3screwSlotWidth&#34;] * 2
            + (
                self.config[&#34;m3screwSlotDistanceFromSide&#34;]
                - self.config[&#34;m3screwSlotWidth&#34;] / 2
            )
            * 2
        ) &gt; self.config[&#34;panelWidth&#34;]:
            if screwSlots == &#34;auto&#34;:
                screwSlots = &#34;tlbr&#34;
            if screwSlots == &#34;auto-tlbr&#34;:
                screwSlots = &#34;tlbr&#34;
            if screwSlots == &#34;auto-trbl&#34;:
                screwSlots = &#34;trbl&#34;
            if screwSlots == &#34;auto-center&#34;:
                screwSlots = &#34;center&#34;
        else:  # Large enough for 4 slots
            if screwSlots == &#34;auto&#34;:
                screwSlots = &#34;all&#34;
            if screwSlots == &#34;auto-tlbr&#34;:
                screwSlots = &#34;all&#34;
            if screwSlots == &#34;auto-trbl&#34;:
                screwSlots = &#34;all&#34;
            if screwSlots == &#34;auto-center&#34;:
                screwSlots = &#34;all&#34;
        if screwSlots == &#34;tlbr&#34;:
            screwSlotTopLeft = True
            screwSlotBottomRight = True
        if screwSlots == &#34;trbl&#34;:
            screwSlotTopRight = True
            screwSlotBottomLeft = True
        if screwSlots == &#34;center&#34;:
            screwSlotTopCenter = True
            screwSlotBottomCenter = True
        if screwSlots == &#34;all&#34;:
            screwSlotTopLeft = True
            screwSlotTopRight = True
            screwSlotBottomLeft = True
            screwSlotBottomRight = True

        screwPoints = []
        if screwSlotTopLeft:
            screwPoints.append(
                (
                    self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                    self.config[&#34;panelHeight&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromTop&#34;],
                )
            )
        if screwSlotTopCenter:
            screwPoints.append(
                (
                    self.config[&#34;panelWidth&#34;] / 2,
                    self.config[&#34;panelHeight&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromTop&#34;],
                )
            )
        if screwSlotTopRight:
            screwPoints.append(
                (
                    self.config[&#34;panelWidth&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                    self.config[&#34;panelHeight&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromTop&#34;],
                )
            )
        if screwSlotBottomLeft:
            screwPoints.append(
                (
                    self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                    self.config[&#34;m3screwSlotDistanceFromBottom&#34;],
                )
            )
        if screwSlotBottomCenter:
            screwPoints.append(
                (
                    self.config[&#34;panelWidth&#34;] / 2,
                    self.config[&#34;m3screwSlotDistanceFromBottom&#34;],
                )
            )
        if screwSlotBottomRight:
            screwPoints.append(
                (
                    self.config[&#34;panelWidth&#34;]
                    - self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                    self.config[&#34;m3screwSlotDistanceFromBottom&#34;],
                )
            )
        if screwPoints != []:
            self.panel = (
                self.panel.faces(&#34;&gt;Z&#34;)
                .workplane()
                .center(-self.config[&#34;panelWidth&#34;] / 2, -self.config[&#34;panelHeight&#34;] / 2)
                .pushPoints(screwPoints)
                .slot2D(
                    self.config[&#34;m3screwSlotWidth&#34;],
                    self.config[&#34;m3screwSlotHeight&#34;],
                    0,
                )
                .cutThruAll()
            )

    def addEurorackPanel(
        self,
        hp: int,
        screwSlots=&#34;auto&#34;,
    ):
        &#34;&#34;&#34;Adds a Eurorack panel with screw slots. Eurorack width is defined in hp().

        Eurorack sizes are generally an even number of hp, such as 4hp or 8hp.
        3hp and 5hp are the only odd number sizes commonly seen in commercial hardware.

        Screw slots in the corners provide better tolerances than holes
        in a DIY printed system. If the panel is too small for four slots,
        there will be only two by default.

        screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
        &#34;&#34;&#34;
        self.config[&#34;panelWidthTolerance&#34;] = self.config[&#34;eurorackWidthTolerance&#34;]
        self.addPanel(self.config[&#34;hp&#34;] * hp, self.config[&#34;eurorackHeight&#34;], screwSlots)

    def add1UIJPanel(
        self,
        hp: int,
        screwSlots=&#34;auto&#34;,
    ):
        &#34;&#34;&#34;Adds a 1U Tile (Intellijel size) panel with screw slots. Eurorack width is defined in hp().

        Note that there are two incompatible 1U tile standards: Intellijel and PulpLogic.

        Screw slots in the corners provide better tolerances than holes
        in a DIY printed system. If the panel is too small for four slots,
        there will be only two by default.

        screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
        &#34;&#34;&#34;
        self.config[&#34;panelWidthTolerance&#34;] = self.config[&#34;1UIJWidthTolerance&#34;]
        self.addPanel(self.config[&#34;hp&#34;] * hp, self.config[&#34;1UIJHeight&#34;], screwSlots)

    def addKosmoPanel(
        self,
        khp: int,
        screwSlots=&#34;auto&#34;,
    ):
        &#34;&#34;&#34;Adds a Kosmo panel with screw slots. khp argument is the amount of 25mm columns.

        Kosmo, also known as Metric 5U, is a format compatible with Eurorack
        popularized by Youtuber Sam Battle (Look Mum No Computer), that uses big jacks.
        It has a horizontal pitch of 25mm (called khp in Synth Printer for simplicity)

        Screw slots in the corners provide better tolerances than holes
        in a DIY printed system. Kosmo panels are always large enough for four slots,
        but you can explicitly set a different configuration of slots.

        screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
        &#34;&#34;&#34;
        self.config[&#34;panelWidthTolerance&#34;] = self.config[&#34;kosmoWidthTolerance&#34;]
        self.addPanel(
            self.config[&#34;khp&#34;] * khp,
            self.config[&#34;kosmoHeight&#34;],
            screwSlots=screwSlots,
        )

    def cutPanelWidthTolerance(self):
        &#34;&#34;&#34;Automatically called during `render()` for Eurorack and 1UIJ:
        makes the panel a bit smaller than its nominal size laterally to account
        for thermal expansion and misaligned neighboring panels.
        Kosmo panels are naturally a bit smaller than the hp grid (they are on a
        25mm grid, while hp are on a 5.08mm grid), as a result, they don&#39;t need
        this shave.
        &#34;&#34;&#34;
        # FIXME: Trial and error values that make no sense.
        # Something&#39;s broken elsewhere!
        # FIXME: Test print Euro / IJ: Do the tolerances provide enough extrusions?
        if self.config[&#34;panelWidthTolerance&#34;] == 0:
            return
        self.cutRect(
            0,
            0,
            self.config[&#34;panelWidthTolerance&#34;],
            self.config[&#34;panelHeight&#34;] * 2,
            False,
        )

        self.cutRect(
            self.config[&#34;panelWidth&#34;] - self.config[&#34;panelWidthTolerance&#34;] / 2,
            0,
            self.config[&#34;panelWidthTolerance&#34;],
            self.config[&#34;panelHeight&#34;] * 2,
            False,
        )

    #######################################################################
    ### Panel engravings
    #######################################################################

    def engraveLine(
        self,
        fromX: float,
        fromY: float,
        angle: float,
        length: float,
        width: float,
        depth: float = 0,
    ):
        &#34;&#34;&#34;Engraves a line on the front of the panel.

        If the depth parameter is omitted or 0, the default depth is used.

        Be sure to inspect both sides of the print to make sure there aren&#39;t
        any sections that are too thin!
        &#34;&#34;&#34;
        if not self.config[&#34;panelRender&#34;]:
            return
        if depth == 0:
            depth = self.config[&#34;panelEngravingDepth&#34;]
        cutout = (
            cq.Workplane(&#34;XY&#34;)
            .lineTo(-width / 2, 0)
            .lineTo(-width / 2, -length)
            .lineTo(width / 2, -length)
            .lineTo(width / 2, 0)
            .close()
            .extrude(depth)
            .rotate((0, 0, 0), (0, 0, 1), angle)
            .translate(
                (
                    -self.config[&#34;panelWidth&#34;] / 2 + fromX,
                    -self.config[&#34;panelHeight&#34;] / 2 + fromY,
                    -self.config[&#34;panelThickness&#34;] / 2,
                )
            )
        )
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .cut(cutout)
        )

    #######################################################################
    ### Rails
    #######################################################################

    # All this stuff is some real spaghetti.
    # It deserves a complete rewrite, and could take 1/5th the code.
    # But it works, so rewrite it yourself if you care.
    # Otherwise, don&#39;t bother me about it.

    def cutRail(
        self,
        x: float,
        y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
    ):
        &#34;&#34;&#34;Make a hole for a hp rail. The rail is added to the supports layer,
        not the panel layer.&#34;&#34;&#34;
        if not self.config[&#34;panelRender&#34;]:
            return
        width = hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2
        height = self.config[&#34;railsHeight&#34;] + self.config[&#34;cradleTolerance&#34;] * 2
        if orientation == &#34;vertical&#34;:
            width, height = height, width
        if centered:
            self.cutRect(x, y, width, height, 0, centered)
        else:
            self.cutRect(
                x - self.config[&#34;cradleTolerance&#34;],
                y - self.config[&#34;cradleTolerance&#34;],
                width,
                height,
                0,
                centered,
            )

    def supportRail(
        self,
        _x: float,
        _y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
    ):
        &#34;&#34;&#34;Adds a hp rail to the support layer. Requires a hole from cutRail().&#34;&#34;&#34;
        if not self.config[&#34;supportsRender&#34;]:
            return
        width = hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2
        height = self.config[&#34;railsHeight&#34;] + self.config[&#34;cradleTolerance&#34;] * 2
        if orientation != &#34;horizontal&#34;:
            width, height = height, width

        if centered:
            x = -self.config[&#34;panelWidth&#34;] / 2 + _x
            y = -self.config[&#34;panelHeight&#34;] / 2 + _y
        else:
            x = (
                -self.config[&#34;panelWidth&#34;] / 2
                + _x
                + width / 2
                - self.config[&#34;cradleTolerance&#34;]
            )
            y = (
                -self.config[&#34;panelHeight&#34;] / 2
                + _y
                + height / 2
                - self.config[&#34;cradleTolerance&#34;]
            )

        self.supports = (
            # Extrude on the inside
            self.supports.moveTo(x, y)
            .rect(width, height)
            .extrude(-self.config[&#34;panelThickness&#34;] + self.config[&#34;railsFrontRecess&#34;])
            # Extrude on the back
            .moveTo(x, y)
            .rect(width, height)
            .extrude(self.config[&#34;railsSupportDepthBack&#34;])
        )

        if orientation == &#34;horizontal&#34;:
            x = (
                -self.config[&#34;panelWidth&#34;] / 2
                + _x
                + (self.config[&#34;hp&#34;] - self.config[&#34;railsScrewDiameter&#34;]) / 2
                + self.config[&#34;railsScrewDiameter&#34;] / 2
            )
            if centered:
                x = x - hp(hpWidth) / 2
        else:
            y = (
                -self.config[&#34;panelHeight&#34;] / 2
                + _y
                + (self.config[&#34;hp&#34;] - self.config[&#34;railsScrewDiameter&#34;]) / 2
                + self.config[&#34;railsScrewDiameter&#34;] / 2
            )
            if centered:
                y = y - hp(hpWidth) / 2

        # Can&#39;t get rarray to work here.
        if orientation == &#34;horizontal&#34;:
            for n in range(hpWidth):
                self.supports = (
                    self.supports.moveTo(x + n * self.config[&#34;hp&#34;], y)
                    .circle(self.config[&#34;railsScrewDiameter&#34;] / 2)
                    .cutThruAll()
                )
        else:
            for n in range(hpWidth):
                self.supports = (
                    self.supports.moveTo(x, y + n * self.config[&#34;hp&#34;])
                    .circle(self.config[&#34;railsScrewDiameter&#34;] / 2)
                    .cutThruAll()
                )

    def addRail(
        self,
        x: float,
        y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
    ):
        &#34;&#34;&#34;Adds a recessed hp rail. The rail is added to the supports layer,
         not the panel layer. Good to build cradles: put a Eurorack modules on
        a Kosmo faceplate, or 1U on a Eurorack one.

        x, y define the center.

        orientation is &#34;horizontal&#34; by default, otherwise &#34;vertical&#34;
        &#34;&#34;&#34;
        self.cutRail(x, y, hpWidth, centered, orientation)
        self.supportRail(x, y, hpWidth, centered, orientation)

    def previewPanel(
        self,
        x: float,
        y: float,
        hpWidth: int,
        height: float,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
    ):
        if not self.config[&#34;previewRender&#34;]:
            return
        if orientation == &#34;horizontal&#34;:
            if centered:
                self.previewBoxOnFront(
                    x + self.config[&#34;cradleTolerance&#34;],
                    y
                    + height / 2
                    - self.config[&#34;railsHeight&#34;] / 2
                    + self.config[&#34;cradleTolerance&#34;] * 2,
                    hp(hpWidth),
                    height,
                    1.6,
                )
            else:
                self.previewBoxOnFront(
                    x + hp(hpWidth) / 2 + self.config[&#34;cradleTolerance&#34;],
                    y + height / 2 + self.config[&#34;cradleTolerance&#34;] * 2,
                    hp(hpWidth),
                    height,
                    1.6,
                )
        else:  # vertical
            if centered:
                self.previewBoxOnFront(
                    x
                    + height / 2
                    - self.config[&#34;railsHeight&#34;] / 2
                    + self.config[&#34;cradleTolerance&#34;] * 2,
                    y + self.config[&#34;cradleTolerance&#34;],
                    height,
                    hp(hpWidth),
                    1.6,
                )
            else:
                self.previewBoxOnFront(
                    x + height / 2 + self.config[&#34;cradleTolerance&#34;] * 2,
                    y + hp(hpWidth) / 2 + self.config[&#34;cradleTolerance&#34;],
                    height,
                    hp(hpWidth),
                    1.6,
                )

    def addCradle(
        self,
        x: float,
        y: float,
        hpWidth: int,
        height: float,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
        supportTop: bool = True,
        supportRight: bool = True,
        supportBottom: bool = True,
        supportLeft: bool = True,
    ):
        &#34;&#34;&#34;Adds a pair of recessed hp rails and a hole for modules.
        The rail is added to the supports layer, not the panel layer.
        You probably want to use `addEurorackCradle()` or
        `add1UIJCradle()` instead.
        &#34;&#34;&#34;
        # Add the two rails
        self.addRail(x, y, hpWidth, centered, orientation)
        if orientation == &#34;horizontal&#34;:
            self.addRail(
                x,
                y + height - self.config[&#34;m3Diameter&#34;] * 2,
                hpWidth,
                centered,
                orientation,
            )
        else:
            self.addRail(
                x + height - self.config[&#34;m3Diameter&#34;] * 2,
                y,
                hpWidth,
                centered,
                orientation,
            )
        # Cut a hole between those rails
        if orientation == &#34;horizontal&#34;:
            if centered:
                self.cutRect(
                    x,
                    y + height / 2 - self.config[&#34;railsHeight&#34;] / 2,
                    hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                    height + self.config[&#34;cradleTolerance&#34;] * 2,
                    0,
                    centered,
                )
                offset = -hp(hpWidth) / 2
                x1 = x - 3 + offset
                x2 = x + hp(hpWidth) + offset
                y1 = y - self.config[&#34;railsHeight&#34;] / 2 - 3
                y2 = y + height - 2
            else:
                self.cutRect(
                    x - self.config[&#34;cradleTolerance&#34;],
                    y - self.config[&#34;cradleTolerance&#34;],
                    hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                    height + self.config[&#34;cradleTolerance&#34;] * 2,
                    0,
                    centered,
                )
                offset = 0
                x1 = x - 3 + offset
                x2 = x + hp(hpWidth) + offset
                y1 = y - 3
                y2 = y + height + 2
            w = hp(hpWidth) + 6
            h = height + 6
        else:  # vertical
            if centered:
                self.cutRect(
                    x + height / 2 - self.config[&#34;railsHeight&#34;] / 2,
                    y,
                    height + self.config[&#34;cradleTolerance&#34;] * 2,
                    hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                    0,
                    centered,
                )
                x1 = (
                    x - self.config[&#34;railsHeight&#34;] * 0.7
                )  # FIXME: IDK why it needs this number. This prolly breaks alt values.
                x2 = x + height - 2
                y1 = y - hp(hpWidth) / 2 - 3
                y2 = y + hp(hpWidth) / 2
            else:
                self.cutRect(
                    x - self.config[&#34;cradleTolerance&#34;],
                    y - self.config[&#34;cradleTolerance&#34;],
                    height + self.config[&#34;cradleTolerance&#34;] * 2,
                    hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                    0,
                    centered,
                )
                x1 = x - 3
                x2 = x + height + 2
                y1 = y - 3
                y2 = y + hp(hpWidth)
            w = height + 6
            h = hp(hpWidth) + 6
        if supportTop:
            self.supportBar(
                x1,
                y1,
                w,
                3 + self.config[&#34;cradleTolerance&#34;] * 2,
                self.config[&#34;railsSupportDepthBack&#34;],
                False,
            )
        if supportBottom:
            self.supportBar(
                x1,
                y2 - self.config[&#34;cradleTolerance&#34;] * 2,
                w,
                3 + self.config[&#34;cradleTolerance&#34;] * 2,
                self.config[&#34;railsSupportDepthBack&#34;],
                False,
            )
        if supportLeft:
            self.supportBar(
                x1,
                y1,
                3 + self.config[&#34;cradleTolerance&#34;] * 2,
                h,
                self.config[&#34;railsSupportDepthBack&#34;],
                False,
            )
        if supportRight:
            self.supportBar(
                x2 - self.config[&#34;cradleTolerance&#34;] * 2,
                y1,
                3 + self.config[&#34;cradleTolerance&#34;] * 2,
                h,
                self.config[&#34;railsSupportDepthBack&#34;],
                False,
            )

        self.previewPanel(x, y, hpWidth, height, centered, orientation)

    def addEurorackCradle(
        self,
        x: float,
        y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
        supportTop: bool = True,
        supportRight: bool = True,
        supportBottom: bool = True,
        supportLeft: bool = True,
    ):
        &#34;&#34;&#34;Adds a pair of recessed hp rails and a hole for modules.
        The rail is added to the supports layer, not the panel layer.
        Screw holes are spaced vertically 122.5mm apart for Eurorack.
        There are supports around the cradle for increased strength.

        This footprint will probbly not work with custom values
        without modifying the code.

        Printed rails hold modules satisfactorily using M3x8mm screws, and
        the holes last a dozen screwing cycles before becoming too enlarged
        to hold things well. For increased safety, use longer screws and nuts.

        Strongly advised to print with supports, but will still print OK without.

        x, y define the center hole of the top rail if centered, that is,
        if the rail is 3hp, the coordinates define the center of the 2nd hole.
        If not centered, the coordinates define the top-left of the
        opening window.

        orientation is &#34;horizontal&#34; by default, otherwise &#34;vertical&#34;

        supportTop, supportRight, supportBottom, supportLeft can be set to False
        to allow stacking rails next to each other.&#34;&#34;&#34;
        self.addCradle(
            x,
            y,
            hpWidth,
            self.config[&#34;eurorackHeight&#34;],
            centered,
            orientation,
            supportTop,
            supportRight,
            supportBottom,
            supportLeft,
        )

    def add1UIJCradle(
        self,
        x: float,
        y: float,
        hpWidth: int,
        centered: bool = True,
        orientation: str = &#34;horizontal&#34;,
        supportTop: bool = True,
        supportRight: bool = True,
        supportBottom: bool = True,
        supportLeft: bool = True,
    ):
        &#34;&#34;&#34;Adds a pair of recessed hp rails and a hole for modules.
        The rail is added to the supports layer, not the panel layer.
        Screw holes are spaced vertically 33.65mm apart for 1U (Intellijel).
        There are supports around the cradle for increased strength.

        This footprint will probbly not work with custom values
        without modifying the code.

        Printed rails hold modules satisfactorily using M3x8mm screws, and
        the holes last a dozen screwing cycles before becoming too enlarged
        to hold things well. For increased safety, use longer screws and nuts.

        Strongly advised to print with supports, but will still print OK without.

        x, y define the center hole of the top rail if centered, that is,
        if the rail is 3hp, the coordinates define the center of the 2nd hole.
        If not centered, the coordinates define the top-left of the
        opening window.

        orientation is &#34;horizontal&#34; by default, otherwise &#34;vertical&#34;

        supportTop, supportRight, supportBottom, supportLeft can be set to False
        to allow stacking rails next to each other.

        Note: This footprint is currently untested.
        &#34;&#34;&#34;
        self.addCradle(
            x,
            y,
            hpWidth,
            self.config[&#34;1UIJHeight&#34;],
            centered,
            orientation,
            supportTop,
            supportRight,
            supportBottom,
            supportLeft,
        )

    #######################################################################
    ### Support structures
    #######################################################################

    # Every function adding to the supports layer has support at the
    # start of the name.

    def supportBar(
        self,
        x: float,
        y: float,
        width: float,
        height: float,
        depth: float,
        centered: bool = False,
    ):
        &#34;&#34;&#34;Adds a box on the supports layer.

        x, y define the top-left of the box as seen from the front
        &#34;&#34;&#34;
        if not self.config[&#34;supportsRender&#34;]:
            return
        if centered:
            x = -self.config[&#34;panelWidth&#34;] / 2 + x
            y = -self.config[&#34;panelHeight&#34;] / 2 + y
        else:
            x = -self.config[&#34;panelWidth&#34;] / 2 + x + width / 2
            y = -self.config[&#34;panelHeight&#34;] / 2 + y + height / 2
        self.supports = (
            self.supports.moveTo(
                x,
                y,
            )
            .rect(width, height)
            .extrude(depth)
        )

    #######################################################################
    ### Drill template marks
    #######################################################################

    # Drill template marks are simple cross shapes that will more or less
    # look like crosses when exported at typical sizes.
    # Every function adding to the drillTemplate layer has mark at the
    # start of the name

    def markOutline(self):
        &#34;&#34;&#34;Add an outline to the drill template layer. This ensures proper
        SVG export. This is automatically done when adding a panel.&#34;&#34;&#34;

        self.drillTemplate = (
            self.drillTemplate.moveTo(  # Top
                0,
                -self.config[&#34;panelHeight&#34;] / 2
                + self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
            )
            .rect(
                self.config[&#34;panelWidth&#34;],
                self.config[&#34;DrillTemplateMarkThickness&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
            .moveTo(  # Bottom
                0,
                self.config[&#34;panelHeight&#34;] / 2
                - self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
            )
            .rect(
                self.config[&#34;panelWidth&#34;],
                self.config[&#34;DrillTemplateMarkThickness&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
            .moveTo(  # Left
                -self.config[&#34;panelWidth&#34;] / 2
                + self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
                0,
            )
            .rect(
                self.config[&#34;DrillTemplateMarkThickness&#34;],
                self.config[&#34;panelHeight&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
            .moveTo(  # Right
                self.config[&#34;panelWidth&#34;] / 2
                - self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
                0,
            )
            .rect(
                self.config[&#34;DrillTemplateMarkThickness&#34;],
                self.config[&#34;panelHeight&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
        )

    def markCross(self, x: float, y: float):
        &#34;&#34;&#34;Adds a mark on the drill template layer. At typical synth panel
        sizes, it will show up as a cross the perfect size for printing out and
        using as a drill template.

        x, y define the center of the mark as seen from the front.
        &#34;&#34;&#34;
        self.drillTemplate = (
            self.drillTemplate.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(
                self.config[&#34;DrillTemplateMarkLength&#34;],
                self.config[&#34;DrillTemplateMarkThickness&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
            .moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(
                self.config[&#34;DrillTemplateMarkThickness&#34;],
                self.config[&#34;DrillTemplateMarkLength&#34;],
            )
            .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
        )

    def markRect(self, x: float, y: float, width: float, height: float):
        &#34;&#34;&#34;Marks a rectangle on the drill template.

        x, y define the center.&#34;&#34;&#34;

        self.drillTemplate = (
            self.drillTemplate.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(width, height)
            .extrude(1)
            .moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .rect(
                width - self.config[&#34;DrillTemplateMarkThickness&#34;] * 2,
                height - self.config[&#34;DrillTemplateMarkThickness&#34;] * 2,
            )
            .cutThruAll()
        )

    def markHole(self, x: float, y: float, diameter: float):
        &#34;&#34;&#34;Marks a circular hole on the drill template.

        x, y define the center.

        FIXME: Nasty implementation, and requires marking circles before crosses

        &#34;&#34;&#34;
        self.drillTemplate = (
            self.drillTemplate.moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .circle(diameter / 2)
            .extrude(1)
            .moveTo(
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
            )
            .circle(diameter / 2 - self.config[&#34;DrillTemplateMarkThickness&#34;])
            .cutThruAll()
        )
        return

    #######################################################################
    ### Buttons and switches
    #######################################################################

    def cutArcadeButton30mm(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;arcade30mmButtonWithTolerance&#34;])

    def previewArcadeButton30mm(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 32.3, 3.4)
        self.previewCylinderOnFront(x, y, 24, 7)
        self.previewCylinderOnBack(x, y, 24, 24.4)
        self.previewCylinderOnBack(x, y, 34.8, 6.5)

    def markArcadeButton30mm(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;arcade30mmButtonWithTolerance&#34;])
        self.markCross(x, y)

    def addArcadeButton30mm(self, x: float, y: float):
        &#34;&#34;&#34;Should work with all major types of 30mm arcade buttons.

        30mm is the size of action buttons commonly seen in arcade cabinets.
        Smaller buttons like the start button are 24mm.

        Tested with the Sanwa OBSF-30 snap-in button.
        Sanwas have a hair trigger and a concave surface.

        Also tested with an unidentified screw-in type. The preview includes its retaining ring.

        Also tested with an unidentified Happ type.
        Happ buttons are concave are more commonly seen on American games.
        They are much deeper than on the preview.
        &#34;&#34;&#34;
        self.cutArcadeButton30mm(x, y)
        self.previewArcadeButton30mm(x, y)
        self.markArcadeButton30mm(x, y)

    def cutArcadeButton24mm(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;arcade24mmButtonWithTolerance&#34;])
        self.cutHole(
            x,
            y,
            self.config[&#34;arcade24mmButtonAdditionalClearanceDiameter&#34;],
            self.config[&#34;arcade24mmButtonAdditionalClearanceDepth&#34;],
        )

    def previewArcadeButton24mm(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 27, 3.4)
        self.previewCylinderOnFront(x, y, 22, 7)
        self.previewCylinderOnBack(x, y, 24, 24.4)
        self.previewCylinderOnBack(x, y, 28, 6)

    def markArcadeButton24mm(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;arcade24mmButtonWithTolerance&#34;])
        self.markCross(x, y)

    def addArcadeButton24mm(self, x: float, y: float):
        &#34;&#34;&#34;Should work with all major types of 24mm arcade buttons.

        24mm is the size of utility buttons (like the start button) commonly seen in arcade cabinets.
        Actual action buttons are 30mm.

        Uses the dimensions for the Sanwa OBSF-24 snap-in button.
        Sanwas have a hair trigger and a concave surface.

        Also tested with an unidentified screw-in type. The preview includes its retaining ring.
        &#34;&#34;&#34;
        self.cutArcadeButton24mm(x, y)
        self.previewArcadeButton24mm(x, y)
        self.markArcadeButton24mm(x, y)

    def cutMiniToggleSwitch(self, x: float, y: float, orientation: str = &#34;horizontal&#34;):
        if not self.config[&#34;panelRender&#34;]:
            return
        if orientation == &#34;horizontal&#34;:
            width = self.config[&#34;miniToggleSwitchWidthWithTolerance&#34;]
            length = self.config[&#34;miniToggleSwitchLengthWithTolerance&#34;]
        else:
            width = self.config[&#34;miniToggleSwitchLengthWithTolerance&#34;]
            length = self.config[&#34;miniToggleSwitchWidthWithTolerance&#34;]

        self.cutHole(x, y, self.config[&#34;miniToggleSwitchDiameterWithTolerance&#34;])
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(width, length)
            .cutBlind(-self.config[&#34;miniToggleSwitchNotchDepth&#34;])
        )

    def previewMiniToggleSwitch(
        self, x: float, y: float, orientation: str = &#34;horizontal&#34;
    ):
        if not self.config[&#34;previewRender&#34;]:
            return
        if orientation == &#34;horizontal&#34;:
            width = self.config[&#34;miniToggleSwitchWidth&#34;]
            length = self.config[&#34;miniToggleSwitchLength&#34;]
        else:
            width = self.config[&#34;miniToggleSwitchLength&#34;]
            length = self.config[&#34;miniToggleSwitchWidth&#34;]
        self.previewBoxOnBack(x, y, width, length, 13.6)
        self.previewCylinderOnFront(x, y, self.config[&#34;miniToggleSwitchDiameter&#34;], 19)

    def markMiniToggleSwitch(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;miniToggleSwitchDiameterWithTolerance&#34;])
        self.markCross(x, y)

    def addMiniToggleSwitch(self, x: float, y: float, orientation: str = &#34;horizontal&#34;):
        &#34;&#34;&#34;A mini toggle switch, with a retaining notch.

        This will fit the switches often sold as the &#34;MTS-100&#34; series by Aliexpress vendors that have only a single row of pins.

        It will not fit DPDT switches that have two rows of pins, those are bigger.

        orientation: &#34;horizontal&#34; (default) or &#34;vertical&#34;.
        &#34;&#34;&#34;
        self.cutMiniToggleSwitch(x, y, orientation)
        self.previewMiniToggleSwitch(x, y, orientation)
        self.markMiniToggleSwitch(x, y)

    #######################################################################
    ### Potentiometers, rotary encoders, sliders
    #######################################################################

    def cutPotentiometer(
        self,
        x: float,
        y: float,
        notchOrientation: str = &#34;all&#34;,
        rotaryEncoderNotch: bool = False,
    ):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;potentiometerHoleDiameterWithTolerance&#34;])
        # List the notches
        points = []  # default to &#34;none&#34; configuration
        if notchOrientation == &#34;top&#34; or notchOrientation == &#34;all&#34;:
            points.append((0, -self.config[&#34;potentiometerNotchDistanceFromCenter&#34;]))
        if notchOrientation == &#34;right&#34; or notchOrientation == &#34;all&#34;:
            points.append((self.config[&#34;potentiometerNotchDistanceFromCenter&#34;], 0))
        if notchOrientation == &#34;bottom&#34; or notchOrientation == &#34;all&#34;:
            points.append((0, self.config[&#34;potentiometerNotchDistanceFromCenter&#34;]))
        if notchOrientation == &#34;left&#34; or notchOrientation == &#34;all&#34;:
            points.append((-self.config[&#34;potentiometerNotchDistanceFromCenter&#34;], 0))
        # Cut the notches
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .pushPoints(points)
            .hole(
                self.config[&#34;potentiometerNotchDiameter&#34;],
                self.config[&#34;potentiometerNotchDepth&#34;],
            )
        )
        # Notch for the encoder
        if rotaryEncoderNotch:
            self.panel = (
                self.panel.faces(&#34;&gt;Z&#34;)
                .vertices(&#34;&lt;XY&#34;)
                .workplane(centerOption=&#34;CenterOfMass&#34;)
                .center(x, y)
                .rect(
                    self.config[&#34;rotaryEncoderWidthWithTolerance&#34;],
                    self.config[&#34;rotaryEncoderHeightWithTolerance&#34;],
                )
                .cutBlind(-self.config[&#34;rotaryEncoderNotchDepth&#34;])
            )

    def previewPotentiometer(self, x: float, y: float, lugsOrientation: str = &#34;all&#34;):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 6, 21)
        self.previewCylinderOnFront(x, y, 9.6, 1.6)
        self.previewCylinderOnBack(x, y, 16, 8)
        if lugsOrientation == &#34;all&#34; or lugsOrientation == &#34;bottom&#34;:
            self.previewBoxOnBack(x, y + 8, 15, 18, 2.4)
        if lugsOrientation == &#34;top&#34;:
            self.previewBoxOnBack(x, y - 8, 15, 18, 2.4)
        if lugsOrientation == &#34;left&#34;:
            self.previewBoxOnBack(x - 8, y, 18, 15, 2.4)
        if lugsOrientation == &#34;right&#34;:
            self.previewBoxOnBack(x + 8, y, 18, 15, 2.4)

    def markPotentiometer(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;potentiometerHoleDiameterWithTolerance&#34;])
        self.markCross(x, y)

    def addPotentiometer(
        self,
        x: float,
        y: float,
        notchOrientation: str = &#34;all&#34;,
        lugsOrientation: str = &#34;all&#34;,
        rotaryEncoderNotch: bool = False,
    ):
        &#34;&#34;&#34;Fits most types of panel-mount potentiometers with a 6mm shaft.

        There will be four notches around the hole, allowing you to catch the
        retaining tab of the potentiometer in the most convenient orientation
        possible.

        Common rotary encoders such as EC11 could use a thinner panel for the
        shaft to protrude sufficiently, in which case, set `rotaryEncoderNotch`
        to `True` to cut a rectangle in the back of the  panel.

        If you want a knob, add it separately with addKnob()

        The orientation parameters are seen from the front, and are:
        &#34;all&#34;, &#34;none&#34;, &#34;top&#34;, &#34;left&#34;, &#34;right&#34;, &#34;bottom&#34;.

        The retaining notches aren&#39;t always on the same side, depending on the
        type of potentiometer! If in doubt, just leave it to &#34;all&#34; to add 4 notches.

        The preview size for the lugs doesn&#39;t account for the possibility of bending them,
        so it might be safe to have this area overlap other stuff a little.
        &#34;&#34;&#34;
        self.cutPotentiometer(x, y, notchOrientation, rotaryEncoderNotch)
        self.previewPotentiometer(x, y, lugsOrientation)
        self.markPotentiometer(x, y)

    def previewKnob(self, x: float, y: float, diameter: float, depth: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, diameter, depth + 5)

    def addKnob(self, x: float, y: float, diameter: float, depth: float):
        &#34;&#34;&#34;Adds a knob for preview only. Place it at the same location as
        potentiometers and rotary encoders!

        Since there is a lot of variation in knob sizes, and sometimes the
        shaft is left exposed without a knob, it&#39;s not added automatically.&#34;&#34;&#34;
        self.previewKnob(x, y, diameter, depth)

    def cutSlider(
        self,
        x: float,
        y: float,
        sliderWidth: float,
        sliderHeight: float,
        slotWidth: float,
        slotHeight: float,
    ):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(
                sliderWidth,
                sliderHeight,
            )
            .cutBlind(-self.config[&#34;sliderNotchDepth&#34;])
        )
        self.cutRect(x, y, slotWidth, slotHeight, 0, True)

    def previewSlider(
        self, x: float, y: float, sliderWidth: float, sliderHeight: float
    ):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 15, 10)
        self.previewBoxOnBack(x, y, sliderWidth, sliderHeight, 22)

    def markSlider(
        self,
        x: float,
        y: float,
        sliderWidth: float,
        sliderHeight: float,
        slotWidth: float,
        slotHeight: float,
    ):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markRect(x, y, sliderWidth, sliderHeight)
        self.markRect(x, y, slotWidth, slotHeight)

    def addSlider(
        self,
        x: float,
        y: float,
        sliderWidth: float,
        sliderHeight: float,
        slotWidth: float,
        slotHeight: float,
    ):
        &#34;&#34;&#34;For slide potentiomenters. Multiple sizes are common, so you have to
        specify yours.

        No special provision are made to hold them in place, it&#39;s assumed you
        have a PCB or are will add some glue or something similarly nasty.

        x, y: center
        &#34;&#34;&#34;
        self.cutSlider(x, y, sliderWidth, sliderHeight, slotWidth, slotHeight)
        self.previewSlider(x, y, sliderWidth, sliderHeight)
        self.markSlider(x, y, sliderWidth, sliderHeight, slotWidth, slotHeight)

    #######################################################################
    ### Jacks &amp; Sockets
    #######################################################################

    def cutBigJack(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;bigJackDiameterWithTolerance&#34;])
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(
                self.config[&#34;bigJackWidthWithTolerance&#34;],
                self.config[&#34;bigJackHeightWithTolerance&#34;],
            )
            .cutBlind(-self.config[&#34;bigJackNotchDepth&#34;])
        )

    def previewBigJack(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 8.5, 7)
        self.previewCylinderOnFront(x, y, 12.6, 2.2)
        self.previewBoxOnBack(x, y, 16, 16, 27)

    def markBigJack(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;bigJackDiameterWithTolerance&#34;])
        self.markCross(x, y)

    def addBigJack(self, x: float, y: float):
        &#34;&#34;&#34;This fits panel mount 6.35mm jacks with a rectangular base, as used
        in Kosmo builds.

        There is a retaining notch the size of the base to help keep it in place.
        &#34;&#34;&#34;
        self.cutBigJack(x, y)
        self.previewBigJack(x, y)
        self.markBigJack(x, y)

    def cutMiniJack(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;miniJackDiameterWithTolerance&#34;])
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(
                self.config[&#34;miniJackSizeWithTolerance&#34;],
                self.config[&#34;miniJackSizeWithTolerance&#34;],
            )
            .cutBlind(-self.config[&#34;miniJackNotchDepth&#34;])
        )

    def previewMiniJack(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 6, 5.5)
        self.previewCylinderOnFront(x, y, 8, 2.2)
        self.previewBoxOnBack(x, y, 9, 10.5, 12.5)

    def markMiniJack(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;miniJackDiameterWithTolerance&#34;])
        self.markCross(x, y)

    def addMiniJack(self, x: float, y: float):
        &#34;&#34;&#34;This fits 3.5mm PJ398SM &#34;Thonkiconn&#34; 3.5mm jacks and similar.

        There is a retaining notch the size of the base to help keep it in place.
        &#34;&#34;&#34;
        self.cutMiniJack(x, y)
        self.previewMiniJack(x, y)
        self.markMiniJack(x, y)

    def cutMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;midiSocketDiameterWithTolerance&#34;])
        if screws == &#34;horizontal&#34;:
            self.cutHole(
                x - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                y,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.cutHole(
                x + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                y,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
        if screws == &#34;vertical&#34;:
            self.cutHole(
                x,
                y - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.cutHole(
                x,
                y + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )

    def previewMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnBack(x, y, 14, 16)
        if screws == &#34;horizontal&#34;:
            self.previewBoxOnFront(x, y, 28, 19, 1)
        if screws == &#34;vertical&#34;:
            self.previewBoxOnFront(x, y, 19, 28, 1)

    def markMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;midiSocketDiameterWithTolerance&#34;])
        self.markCross(x, y)
        if screws == &#34;horizontal&#34;:
            self.markHole(
                x - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                y,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.markHole(
                x + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                y,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.markCross(x - self.config[&#34;midiSocketScrewDistance&#34;] / 2, y)
            self.markCross(x + self.config[&#34;midiSocketScrewDistance&#34;] / 2, y)
        if screws == &#34;vertical&#34;:
            self.markHole(
                x,
                y - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.markHole(
                x,
                y + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
                self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
            )
            self.markCross(x, y - self.config[&#34;midiSocketScrewDistance&#34;] / 2)
            self.markCross(x, y + self.config[&#34;midiSocketScrewDistance&#34;] / 2)

    def addMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
        &#34;&#34;&#34;Adds a panel mount female DIN socket.

        It fits the aluminum sockets that have two M3 screws on each side.

        screws: &#34;horizontal&#34;, &#34;vertical&#34;, or &#34;none&#34;
        &#34;&#34;&#34;
        self.cutMidiSocket(x, y, screws)
        self.previewMidiSocket(x, y, screws)
        self.markMidiSocket(x, y, screws)

    #######################################################################
    ### Blinkenlichten
    #######################################################################

    def cutLed5mm(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;5mmLedWithTolerance&#34;])

    def previewLed5mm(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 4.7, 3)
        self.previewBoxOnBack(x, y, 4, 1, 17)

    def markLed5mm(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;5mmLedWithTolerance&#34;])
        self.markCross(x, y)

    def addLed5mm(self, x: float, y: float):
        &#34;&#34;&#34;Creates a hole for a 5mm LED protruding from the hole.

        There is no mechanism to hold it in place, but hot glue will do the trick.
        &#34;&#34;&#34;
        self.cutLed5mm(x, y)
        self.previewLed5mm(x, y)
        self.markLed5mm(x, y)

    def cutLed3mm(self, x: float, y: float):
        if not self.config[&#34;panelRender&#34;]:
            return
        self.cutHole(x, y, self.config[&#34;3mmLedWithTolerance&#34;])

    def previewLed3mm(self, x: float, y: float):
        if not self.config[&#34;previewRender&#34;]:
            return
        self.previewCylinderOnFront(x, y, 2.8, 1)
        self.previewBoxOnBack(x, y, 2.7, 1, 17)

    def markLed3mm(self, x: float, y: float):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markHole(x, y, self.config[&#34;3mmLedWithTolerance&#34;])
        self.markCross(x, y)

    def addLed3mm(self, x: float, y: float):
        &#34;&#34;&#34;Creates a hole for a 3mm LED fitting inside the hole.
        On default settings, it will not protrude past the hole, and might
        diffuse a bit of light in the surrounding plastic.

        There is no mechanism to hold it in place, but hot glue will do the trick.
        &#34;&#34;&#34;
        self.cutLed3mm(x, y)
        self.previewLed3mm(x, y)
        self.markLed3mm(x, y)

    def cutDisplayWindow(
        self,
        x: float,
        y: float,
        windowWidth: float = 30,
        windowHeight: float = 15,
        windowHorizontalOffset: float = 0,
        windowVerticalOffset: float = -5,
        screwsHorizontalDistance: float = 40,
        screwsVerticalDistance: float = 40,
        addScrews: bool = True,
    ):
        # FIXME: This is the nastiest way possible to implement a fillet
        # but the only one I could figure out.

        cutout = (
            cq.Workplane(&#34;XY&#34;)
            .box(
                windowWidth + self.config[&#34;panelThickness&#34;],
                windowHeight + self.config[&#34;panelThickness&#34;],
                self.config[&#34;panelThickness&#34;],
            )
            .edges(&#34;&gt;Z&#34;)
            .fillet(self.config[&#34;panelThickness&#34;] * 0.99)
            .translate(
                (
                    -self.config[&#34;panelWidth&#34;] / 2 + x + windowHorizontalOffset,
                    -self.config[&#34;panelHeight&#34;] / 2 + y + windowVerticalOffset,
                    0,
                )
            )
        )
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .cut(cutout)
        )

        # Next, the actual cutout
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x + windowHorizontalOffset, y + windowVerticalOffset)
            .rect(windowWidth, windowHeight)
            .cutThruAll()
        )

        # Now, the screws
        if addScrews:
            self.panel = (
                self.panel.faces(&#34;&gt;Z&#34;)
                .vertices(&#34;&lt;XY&#34;)
                .workplane(centerOption=&#34;CenterOfMass&#34;)
                .center(x, y)
                .rect(
                    screwsHorizontalDistance,
                    screwsVerticalDistance,
                    forConstruction=True,
                )
                .vertices()
                .circle(self.config[&#34;m2DiameterWithTolerance&#34;] / 2)
                .cutThruAll()
            )

    def markDisplayWindow(
        self,
        x: float,
        y: float,
        windowWidth: float = 30,
        windowHeight: float = 15,
        windowHorizontalOffset: float = 0,
        windowVerticalOffset: float = -5,
        screwsHorizontalDistance: float = 40,
        screwsVerticalDistance: float = 40,
        addScrews: bool = True,
    ):
        if not self.config[&#34;drillTemplateRender&#34;]:
            return
        self.markRect(
            x + windowHorizontalOffset,
            y + windowVerticalOffset,
            windowWidth,
            windowHeight,
        )
        if addScrews:
            self.markHole(
                x - screwsHorizontalDistance / 2,
                y - screwsVerticalDistance / 2,
                self.config[&#34;m2DiameterWithTolerance&#34;],
            )
            self.markHole(
                x + screwsHorizontalDistance / 2,
                y - screwsVerticalDistance / 2,
                self.config[&#34;m2DiameterWithTolerance&#34;],
            )
            self.markHole(
                x - screwsHorizontalDistance / 2,
                y + screwsVerticalDistance / 2,
                self.config[&#34;m2DiameterWithTolerance&#34;],
            )
            self.markHole(
                x + screwsHorizontalDistance / 2,
                y + screwsVerticalDistance / 2,
                self.config[&#34;m2DiameterWithTolerance&#34;],
            )
            self.markCross(
                x - screwsHorizontalDistance / 2,
                y - screwsVerticalDistance / 2,
            )
            self.markCross(
                x + screwsHorizontalDistance / 2,
                y - screwsVerticalDistance / 2,
            )
            self.markCross(
                x - screwsHorizontalDistance / 2,
                y + screwsVerticalDistance / 2,
            )
            self.markCross(
                x + screwsHorizontalDistance / 2,
                y + screwsVerticalDistance / 2,
            )

    def addDisplayWindow(
        self,
        x: float,
        y: float,
        windowWidth: float = 30,
        windowHeight: float = 15,
        windowHorizontalOffset: float = 0,
        windowVerticalOffset: float = -5,
        screwsHorizontalDistance: float = 40,
        screwsVerticalDistance: float = 40,
        addScrews: bool = True,
    ):
        &#34;&#34;&#34;Creates a window for a rectangular display mounted with four screws in the corner.

        Every single display available has different dimensions, especially the cheapo OLEDs
        from Aliexpress. Even when the display size is the same, various boards differ by
        a few millimeters.

        The defaults offered are for a non-existent model, for preview purposes.
        Provide your own measurements instead!

        There is no preview widget for this footprint.
        &#34;&#34;&#34;
        self.cutDisplayWindow(
            x,
            y,
            windowWidth,
            windowHeight,
            windowHorizontalOffset,
            windowVerticalOffset,
            screwsHorizontalDistance,
            screwsVerticalDistance,
            addScrews,
        )

        self.markDisplayWindow(
            x,
            y,
            windowWidth,
            windowHeight,
            windowHorizontalOffset,
            windowVerticalOffset,
            screwsHorizontalDistance,
            screwsVerticalDistance,
            addScrews,
        )

    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################
    #######################################################################</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="synthprinter.SynthPrinter.defaultConfig"><code class="name">var <span class="ident">defaultConfig</span></code></dt>
<dd>
<div class="desc"><p>You can override any of the defaultConfig settings by passing them as a
parameter to the constructor. Look at the code for the full list of
settings. Some are dynamically calculated from other settings,
in particular, the tolerances of most elements are expressed as a
multiplier of the main tolerance value.</p>
<p>For example, to replace the main tolerance value of 0.4mm, create a
new object as follows:</p>
<pre><code>sp = SynthPrinter(
    tolerance=0.6,
)
</code></pre>
<p>defaultConfig values are mostly dimensions that have been tested to
work well with 3D printing. You are encouraged to try out the defaults
first. But with a different process than FDM 3D printing, you will want to
make your own configuration profile.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="synthprinter.SynthPrinter.add1UIJCradle"><code class="name flex">
<span>def <span class="ident">add1UIJCradle</span></span>(<span>self, x: float, y: float, hpWidth: int, centered: bool = True, orientation: str = 'horizontal', supportTop: bool = True, supportRight: bool = True, supportBottom: bool = True, supportLeft: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a pair of recessed hp rails and a hole for modules.
The rail is added to the supports layer, not the panel layer.
Screw holes are spaced vertically 33.65mm apart for 1U (Intellijel).
There are supports around the cradle for increased strength.</p>
<p>This footprint will probbly not work with custom values
without modifying the code.</p>
<p>Printed rails hold modules satisfactorily using M3x8mm screws, and
the holes last a dozen screwing cycles before becoming too enlarged
to hold things well. For increased safety, use longer screws and nuts.</p>
<p>Strongly advised to print with supports, but will still print OK without.</p>
<p>x, y define the center hole of the top rail if centered, that is,
if the rail is 3hp, the coordinates define the center of the 2nd hole.
If not centered, the coordinates define the top-left of the
opening window.</p>
<p>orientation is "horizontal" by default, otherwise "vertical"</p>
<p>supportTop, supportRight, supportBottom, supportLeft can be set to False
to allow stacking rails next to each other.</p>
<p>Note: This footprint is currently untested.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add1UIJCradle(
    self,
    x: float,
    y: float,
    hpWidth: int,
    centered: bool = True,
    orientation: str = &#34;horizontal&#34;,
    supportTop: bool = True,
    supportRight: bool = True,
    supportBottom: bool = True,
    supportLeft: bool = True,
):
    &#34;&#34;&#34;Adds a pair of recessed hp rails and a hole for modules.
    The rail is added to the supports layer, not the panel layer.
    Screw holes are spaced vertically 33.65mm apart for 1U (Intellijel).
    There are supports around the cradle for increased strength.

    This footprint will probbly not work with custom values
    without modifying the code.

    Printed rails hold modules satisfactorily using M3x8mm screws, and
    the holes last a dozen screwing cycles before becoming too enlarged
    to hold things well. For increased safety, use longer screws and nuts.

    Strongly advised to print with supports, but will still print OK without.

    x, y define the center hole of the top rail if centered, that is,
    if the rail is 3hp, the coordinates define the center of the 2nd hole.
    If not centered, the coordinates define the top-left of the
    opening window.

    orientation is &#34;horizontal&#34; by default, otherwise &#34;vertical&#34;

    supportTop, supportRight, supportBottom, supportLeft can be set to False
    to allow stacking rails next to each other.

    Note: This footprint is currently untested.
    &#34;&#34;&#34;
    self.addCradle(
        x,
        y,
        hpWidth,
        self.config[&#34;1UIJHeight&#34;],
        centered,
        orientation,
        supportTop,
        supportRight,
        supportBottom,
        supportLeft,
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.add1UIJPanel"><code class="name flex">
<span>def <span class="ident">add1UIJPanel</span></span>(<span>self, hp: int, screwSlots='auto')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a 1U Tile (Intellijel size) panel with screw slots. Eurorack width is defined in hp().</p>
<p>Note that there are two incompatible 1U tile standards: Intellijel and PulpLogic.</p>
<p>Screw slots in the corners provide better tolerances than holes
in a DIY printed system. If the panel is too small for four slots,
there will be only two by default.</p>
<p>screwSlots: options are "auto", "auto-tlbr", "auto-trbl", "auto-center", "none", "all", "tlbr", "trbl", "center"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add1UIJPanel(
    self,
    hp: int,
    screwSlots=&#34;auto&#34;,
):
    &#34;&#34;&#34;Adds a 1U Tile (Intellijel size) panel with screw slots. Eurorack width is defined in hp().

    Note that there are two incompatible 1U tile standards: Intellijel and PulpLogic.

    Screw slots in the corners provide better tolerances than holes
    in a DIY printed system. If the panel is too small for four slots,
    there will be only two by default.

    screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
    &#34;&#34;&#34;
    self.config[&#34;panelWidthTolerance&#34;] = self.config[&#34;1UIJWidthTolerance&#34;]
    self.addPanel(self.config[&#34;hp&#34;] * hp, self.config[&#34;1UIJHeight&#34;], screwSlots)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addArcadeButton24mm"><code class="name flex">
<span>def <span class="ident">addArcadeButton24mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Should work with all major types of 24mm arcade buttons.</p>
<p>24mm is the size of utility buttons (like the start button) commonly seen in arcade cabinets.
Actual action buttons are 30mm.</p>
<p>Uses the dimensions for the Sanwa OBSF-24 snap-in button.
Sanwas have a hair trigger and a concave surface.</p>
<p>Also tested with an unidentified screw-in type. The preview includes its retaining ring.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addArcadeButton24mm(self, x: float, y: float):
    &#34;&#34;&#34;Should work with all major types of 24mm arcade buttons.

    24mm is the size of utility buttons (like the start button) commonly seen in arcade cabinets.
    Actual action buttons are 30mm.

    Uses the dimensions for the Sanwa OBSF-24 snap-in button.
    Sanwas have a hair trigger and a concave surface.

    Also tested with an unidentified screw-in type. The preview includes its retaining ring.
    &#34;&#34;&#34;
    self.cutArcadeButton24mm(x, y)
    self.previewArcadeButton24mm(x, y)
    self.markArcadeButton24mm(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addArcadeButton30mm"><code class="name flex">
<span>def <span class="ident">addArcadeButton30mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Should work with all major types of 30mm arcade buttons.</p>
<p>30mm is the size of action buttons commonly seen in arcade cabinets.
Smaller buttons like the start button are 24mm.</p>
<p>Tested with the Sanwa OBSF-30 snap-in button.
Sanwas have a hair trigger and a concave surface.</p>
<p>Also tested with an unidentified screw-in type. The preview includes its retaining ring.</p>
<p>Also tested with an unidentified Happ type.
Happ buttons are concave are more commonly seen on American games.
They are much deeper than on the preview.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addArcadeButton30mm(self, x: float, y: float):
    &#34;&#34;&#34;Should work with all major types of 30mm arcade buttons.

    30mm is the size of action buttons commonly seen in arcade cabinets.
    Smaller buttons like the start button are 24mm.

    Tested with the Sanwa OBSF-30 snap-in button.
    Sanwas have a hair trigger and a concave surface.

    Also tested with an unidentified screw-in type. The preview includes its retaining ring.

    Also tested with an unidentified Happ type.
    Happ buttons are concave are more commonly seen on American games.
    They are much deeper than on the preview.
    &#34;&#34;&#34;
    self.cutArcadeButton30mm(x, y)
    self.previewArcadeButton30mm(x, y)
    self.markArcadeButton30mm(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addBigJack"><code class="name flex">
<span>def <span class="ident">addBigJack</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"><p>This fits panel mount 6.35mm jacks with a rectangular base, as used
in Kosmo builds.</p>
<p>There is a retaining notch the size of the base to help keep it in place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addBigJack(self, x: float, y: float):
    &#34;&#34;&#34;This fits panel mount 6.35mm jacks with a rectangular base, as used
    in Kosmo builds.

    There is a retaining notch the size of the base to help keep it in place.
    &#34;&#34;&#34;
    self.cutBigJack(x, y)
    self.previewBigJack(x, y)
    self.markBigJack(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addCradle"><code class="name flex">
<span>def <span class="ident">addCradle</span></span>(<span>self, x: float, y: float, hpWidth: int, height: float, centered: bool = True, orientation: str = 'horizontal', supportTop: bool = True, supportRight: bool = True, supportBottom: bool = True, supportLeft: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a pair of recessed hp rails and a hole for modules.
The rail is added to the supports layer, not the panel layer.
You probably want to use <code>addEurorackCradle()</code> or
<code>add1UIJCradle()</code> instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addCradle(
    self,
    x: float,
    y: float,
    hpWidth: int,
    height: float,
    centered: bool = True,
    orientation: str = &#34;horizontal&#34;,
    supportTop: bool = True,
    supportRight: bool = True,
    supportBottom: bool = True,
    supportLeft: bool = True,
):
    &#34;&#34;&#34;Adds a pair of recessed hp rails and a hole for modules.
    The rail is added to the supports layer, not the panel layer.
    You probably want to use `addEurorackCradle()` or
    `add1UIJCradle()` instead.
    &#34;&#34;&#34;
    # Add the two rails
    self.addRail(x, y, hpWidth, centered, orientation)
    if orientation == &#34;horizontal&#34;:
        self.addRail(
            x,
            y + height - self.config[&#34;m3Diameter&#34;] * 2,
            hpWidth,
            centered,
            orientation,
        )
    else:
        self.addRail(
            x + height - self.config[&#34;m3Diameter&#34;] * 2,
            y,
            hpWidth,
            centered,
            orientation,
        )
    # Cut a hole between those rails
    if orientation == &#34;horizontal&#34;:
        if centered:
            self.cutRect(
                x,
                y + height / 2 - self.config[&#34;railsHeight&#34;] / 2,
                hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                height + self.config[&#34;cradleTolerance&#34;] * 2,
                0,
                centered,
            )
            offset = -hp(hpWidth) / 2
            x1 = x - 3 + offset
            x2 = x + hp(hpWidth) + offset
            y1 = y - self.config[&#34;railsHeight&#34;] / 2 - 3
            y2 = y + height - 2
        else:
            self.cutRect(
                x - self.config[&#34;cradleTolerance&#34;],
                y - self.config[&#34;cradleTolerance&#34;],
                hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                height + self.config[&#34;cradleTolerance&#34;] * 2,
                0,
                centered,
            )
            offset = 0
            x1 = x - 3 + offset
            x2 = x + hp(hpWidth) + offset
            y1 = y - 3
            y2 = y + height + 2
        w = hp(hpWidth) + 6
        h = height + 6
    else:  # vertical
        if centered:
            self.cutRect(
                x + height / 2 - self.config[&#34;railsHeight&#34;] / 2,
                y,
                height + self.config[&#34;cradleTolerance&#34;] * 2,
                hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                0,
                centered,
            )
            x1 = (
                x - self.config[&#34;railsHeight&#34;] * 0.7
            )  # FIXME: IDK why it needs this number. This prolly breaks alt values.
            x2 = x + height - 2
            y1 = y - hp(hpWidth) / 2 - 3
            y2 = y + hp(hpWidth) / 2
        else:
            self.cutRect(
                x - self.config[&#34;cradleTolerance&#34;],
                y - self.config[&#34;cradleTolerance&#34;],
                height + self.config[&#34;cradleTolerance&#34;] * 2,
                hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2,
                0,
                centered,
            )
            x1 = x - 3
            x2 = x + height + 2
            y1 = y - 3
            y2 = y + hp(hpWidth)
        w = height + 6
        h = hp(hpWidth) + 6
    if supportTop:
        self.supportBar(
            x1,
            y1,
            w,
            3 + self.config[&#34;cradleTolerance&#34;] * 2,
            self.config[&#34;railsSupportDepthBack&#34;],
            False,
        )
    if supportBottom:
        self.supportBar(
            x1,
            y2 - self.config[&#34;cradleTolerance&#34;] * 2,
            w,
            3 + self.config[&#34;cradleTolerance&#34;] * 2,
            self.config[&#34;railsSupportDepthBack&#34;],
            False,
        )
    if supportLeft:
        self.supportBar(
            x1,
            y1,
            3 + self.config[&#34;cradleTolerance&#34;] * 2,
            h,
            self.config[&#34;railsSupportDepthBack&#34;],
            False,
        )
    if supportRight:
        self.supportBar(
            x2 - self.config[&#34;cradleTolerance&#34;] * 2,
            y1,
            3 + self.config[&#34;cradleTolerance&#34;] * 2,
            h,
            self.config[&#34;railsSupportDepthBack&#34;],
            False,
        )

    self.previewPanel(x, y, hpWidth, height, centered, orientation)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addDisplayWindow"><code class="name flex">
<span>def <span class="ident">addDisplayWindow</span></span>(<span>self, x: float, y: float, windowWidth: float = 30, windowHeight: float = 15, windowHorizontalOffset: float = 0, windowVerticalOffset: float = -5, screwsHorizontalDistance: float = 40, screwsVerticalDistance: float = 40, addScrews: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a window for a rectangular display mounted with four screws in the corner.</p>
<p>Every single display available has different dimensions, especially the cheapo OLEDs
from Aliexpress. Even when the display size is the same, various boards differ by
a few millimeters.</p>
<p>The defaults offered are for a non-existent model, for preview purposes.
Provide your own measurements instead!</p>
<p>There is no preview widget for this footprint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addDisplayWindow(
    self,
    x: float,
    y: float,
    windowWidth: float = 30,
    windowHeight: float = 15,
    windowHorizontalOffset: float = 0,
    windowVerticalOffset: float = -5,
    screwsHorizontalDistance: float = 40,
    screwsVerticalDistance: float = 40,
    addScrews: bool = True,
):
    &#34;&#34;&#34;Creates a window for a rectangular display mounted with four screws in the corner.

    Every single display available has different dimensions, especially the cheapo OLEDs
    from Aliexpress. Even when the display size is the same, various boards differ by
    a few millimeters.

    The defaults offered are for a non-existent model, for preview purposes.
    Provide your own measurements instead!

    There is no preview widget for this footprint.
    &#34;&#34;&#34;
    self.cutDisplayWindow(
        x,
        y,
        windowWidth,
        windowHeight,
        windowHorizontalOffset,
        windowVerticalOffset,
        screwsHorizontalDistance,
        screwsVerticalDistance,
        addScrews,
    )

    self.markDisplayWindow(
        x,
        y,
        windowWidth,
        windowHeight,
        windowHorizontalOffset,
        windowVerticalOffset,
        screwsHorizontalDistance,
        screwsVerticalDistance,
        addScrews,
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addEurorackCradle"><code class="name flex">
<span>def <span class="ident">addEurorackCradle</span></span>(<span>self, x: float, y: float, hpWidth: int, centered: bool = True, orientation: str = 'horizontal', supportTop: bool = True, supportRight: bool = True, supportBottom: bool = True, supportLeft: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a pair of recessed hp rails and a hole for modules.
The rail is added to the supports layer, not the panel layer.
Screw holes are spaced vertically 122.5mm apart for Eurorack.
There are supports around the cradle for increased strength.</p>
<p>This footprint will probbly not work with custom values
without modifying the code.</p>
<p>Printed rails hold modules satisfactorily using M3x8mm screws, and
the holes last a dozen screwing cycles before becoming too enlarged
to hold things well. For increased safety, use longer screws and nuts.</p>
<p>Strongly advised to print with supports, but will still print OK without.</p>
<p>x, y define the center hole of the top rail if centered, that is,
if the rail is 3hp, the coordinates define the center of the 2nd hole.
If not centered, the coordinates define the top-left of the
opening window.</p>
<p>orientation is "horizontal" by default, otherwise "vertical"</p>
<p>supportTop, supportRight, supportBottom, supportLeft can be set to False
to allow stacking rails next to each other.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addEurorackCradle(
    self,
    x: float,
    y: float,
    hpWidth: int,
    centered: bool = True,
    orientation: str = &#34;horizontal&#34;,
    supportTop: bool = True,
    supportRight: bool = True,
    supportBottom: bool = True,
    supportLeft: bool = True,
):
    &#34;&#34;&#34;Adds a pair of recessed hp rails and a hole for modules.
    The rail is added to the supports layer, not the panel layer.
    Screw holes are spaced vertically 122.5mm apart for Eurorack.
    There are supports around the cradle for increased strength.

    This footprint will probbly not work with custom values
    without modifying the code.

    Printed rails hold modules satisfactorily using M3x8mm screws, and
    the holes last a dozen screwing cycles before becoming too enlarged
    to hold things well. For increased safety, use longer screws and nuts.

    Strongly advised to print with supports, but will still print OK without.

    x, y define the center hole of the top rail if centered, that is,
    if the rail is 3hp, the coordinates define the center of the 2nd hole.
    If not centered, the coordinates define the top-left of the
    opening window.

    orientation is &#34;horizontal&#34; by default, otherwise &#34;vertical&#34;

    supportTop, supportRight, supportBottom, supportLeft can be set to False
    to allow stacking rails next to each other.&#34;&#34;&#34;
    self.addCradle(
        x,
        y,
        hpWidth,
        self.config[&#34;eurorackHeight&#34;],
        centered,
        orientation,
        supportTop,
        supportRight,
        supportBottom,
        supportLeft,
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addEurorackPanel"><code class="name flex">
<span>def <span class="ident">addEurorackPanel</span></span>(<span>self, hp: int, screwSlots='auto')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a Eurorack panel with screw slots. Eurorack width is defined in hp().</p>
<p>Eurorack sizes are generally an even number of hp, such as 4hp or 8hp.
3hp and 5hp are the only odd number sizes commonly seen in commercial hardware.</p>
<p>Screw slots in the corners provide better tolerances than holes
in a DIY printed system. If the panel is too small for four slots,
there will be only two by default.</p>
<p>screwSlots: options are "auto", "auto-tlbr", "auto-trbl", "auto-center", "none", "all", "tlbr", "trbl", "center"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addEurorackPanel(
    self,
    hp: int,
    screwSlots=&#34;auto&#34;,
):
    &#34;&#34;&#34;Adds a Eurorack panel with screw slots. Eurorack width is defined in hp().

    Eurorack sizes are generally an even number of hp, such as 4hp or 8hp.
    3hp and 5hp are the only odd number sizes commonly seen in commercial hardware.

    Screw slots in the corners provide better tolerances than holes
    in a DIY printed system. If the panel is too small for four slots,
    there will be only two by default.

    screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
    &#34;&#34;&#34;
    self.config[&#34;panelWidthTolerance&#34;] = self.config[&#34;eurorackWidthTolerance&#34;]
    self.addPanel(self.config[&#34;hp&#34;] * hp, self.config[&#34;eurorackHeight&#34;], screwSlots)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addKnob"><code class="name flex">
<span>def <span class="ident">addKnob</span></span>(<span>self, x: float, y: float, diameter: float, depth: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a knob for preview only. Place it at the same location as
potentiometers and rotary encoders!</p>
<p>Since there is a lot of variation in knob sizes, and sometimes the
shaft is left exposed without a knob, it's not added automatically.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addKnob(self, x: float, y: float, diameter: float, depth: float):
    &#34;&#34;&#34;Adds a knob for preview only. Place it at the same location as
    potentiometers and rotary encoders!

    Since there is a lot of variation in knob sizes, and sometimes the
    shaft is left exposed without a knob, it&#39;s not added automatically.&#34;&#34;&#34;
    self.previewKnob(x, y, diameter, depth)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addKosmoPanel"><code class="name flex">
<span>def <span class="ident">addKosmoPanel</span></span>(<span>self, khp: int, screwSlots='auto')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a Kosmo panel with screw slots. khp argument is the amount of 25mm columns.</p>
<p>Kosmo, also known as Metric 5U, is a format compatible with Eurorack
popularized by Youtuber Sam Battle (Look Mum No Computer), that uses big jacks.
It has a horizontal pitch of 25mm (called khp in Synth Printer for simplicity)</p>
<p>Screw slots in the corners provide better tolerances than holes
in a DIY printed system. Kosmo panels are always large enough for four slots,
but you can explicitly set a different configuration of slots.</p>
<p>screwSlots: options are "auto", "auto-tlbr", "auto-trbl", "auto-center", "none", "all", "tlbr", "trbl", "center"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addKosmoPanel(
    self,
    khp: int,
    screwSlots=&#34;auto&#34;,
):
    &#34;&#34;&#34;Adds a Kosmo panel with screw slots. khp argument is the amount of 25mm columns.

    Kosmo, also known as Metric 5U, is a format compatible with Eurorack
    popularized by Youtuber Sam Battle (Look Mum No Computer), that uses big jacks.
    It has a horizontal pitch of 25mm (called khp in Synth Printer for simplicity)

    Screw slots in the corners provide better tolerances than holes
    in a DIY printed system. Kosmo panels are always large enough for four slots,
    but you can explicitly set a different configuration of slots.

    screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
    &#34;&#34;&#34;
    self.config[&#34;panelWidthTolerance&#34;] = self.config[&#34;kosmoWidthTolerance&#34;]
    self.addPanel(
        self.config[&#34;khp&#34;] * khp,
        self.config[&#34;kosmoHeight&#34;],
        screwSlots=screwSlots,
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addLed3mm"><code class="name flex">
<span>def <span class="ident">addLed3mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a hole for a 3mm LED fitting inside the hole.
On default settings, it will not protrude past the hole, and might
diffuse a bit of light in the surrounding plastic.</p>
<p>There is no mechanism to hold it in place, but hot glue will do the trick.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addLed3mm(self, x: float, y: float):
    &#34;&#34;&#34;Creates a hole for a 3mm LED fitting inside the hole.
    On default settings, it will not protrude past the hole, and might
    diffuse a bit of light in the surrounding plastic.

    There is no mechanism to hold it in place, but hot glue will do the trick.
    &#34;&#34;&#34;
    self.cutLed3mm(x, y)
    self.previewLed3mm(x, y)
    self.markLed3mm(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addLed5mm"><code class="name flex">
<span>def <span class="ident">addLed5mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a hole for a 5mm LED protruding from the hole.</p>
<p>There is no mechanism to hold it in place, but hot glue will do the trick.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addLed5mm(self, x: float, y: float):
    &#34;&#34;&#34;Creates a hole for a 5mm LED protruding from the hole.

    There is no mechanism to hold it in place, but hot glue will do the trick.
    &#34;&#34;&#34;
    self.cutLed5mm(x, y)
    self.previewLed5mm(x, y)
    self.markLed5mm(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addMidiSocket"><code class="name flex">
<span>def <span class="ident">addMidiSocket</span></span>(<span>self, x: float, y: float, screws: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a panel mount female DIN socket.</p>
<p>It fits the aluminum sockets that have two M3 screws on each side.</p>
<p>screws: "horizontal", "vertical", or "none"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
    &#34;&#34;&#34;Adds a panel mount female DIN socket.

    It fits the aluminum sockets that have two M3 screws on each side.

    screws: &#34;horizontal&#34;, &#34;vertical&#34;, or &#34;none&#34;
    &#34;&#34;&#34;
    self.cutMidiSocket(x, y, screws)
    self.previewMidiSocket(x, y, screws)
    self.markMidiSocket(x, y, screws)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addMiniJack"><code class="name flex">
<span>def <span class="ident">addMiniJack</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"><p>This fits 3.5mm PJ398SM "Thonkiconn" 3.5mm jacks and similar.</p>
<p>There is a retaining notch the size of the base to help keep it in place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addMiniJack(self, x: float, y: float):
    &#34;&#34;&#34;This fits 3.5mm PJ398SM &#34;Thonkiconn&#34; 3.5mm jacks and similar.

    There is a retaining notch the size of the base to help keep it in place.
    &#34;&#34;&#34;
    self.cutMiniJack(x, y)
    self.previewMiniJack(x, y)
    self.markMiniJack(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addMiniToggleSwitch"><code class="name flex">
<span>def <span class="ident">addMiniToggleSwitch</span></span>(<span>self, x: float, y: float, orientation: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"><p>A mini toggle switch, with a retaining notch.</p>
<p>This will fit the switches often sold as the "MTS-100" series by Aliexpress vendors that have only a single row of pins.</p>
<p>It will not fit DPDT switches that have two rows of pins, those are bigger.</p>
<p>orientation: "horizontal" (default) or "vertical".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addMiniToggleSwitch(self, x: float, y: float, orientation: str = &#34;horizontal&#34;):
    &#34;&#34;&#34;A mini toggle switch, with a retaining notch.

    This will fit the switches often sold as the &#34;MTS-100&#34; series by Aliexpress vendors that have only a single row of pins.

    It will not fit DPDT switches that have two rows of pins, those are bigger.

    orientation: &#34;horizontal&#34; (default) or &#34;vertical&#34;.
    &#34;&#34;&#34;
    self.cutMiniToggleSwitch(x, y, orientation)
    self.previewMiniToggleSwitch(x, y, orientation)
    self.markMiniToggleSwitch(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addPanel"><code class="name flex">
<span>def <span class="ident">addPanel</span></span>(<span>self, width: float, height: float, screwSlots: str = 'auto')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a rectangular panel of arbitrary dimensions.
You can only add one.</p>
<p>Screw slots in the corners provide better tolerances than holes
in a DIY printed system. If the panel is too small for four slots,
there will be only two by default.</p>
<p>TODO: Add Slots to the drill template</p>
<p>screwSlots: options are "auto", "auto-tlbr", "auto-trbl", "auto-center", "none", "all", "tlbr", "trbl", "center"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addPanel(
    self,
    width: float,
    height: float,
    screwSlots: str = &#34;auto&#34;,
):
    &#34;&#34;&#34;Adds a rectangular panel of arbitrary dimensions.
    You can only add one.

    Screw slots in the corners provide better tolerances than holes
    in a DIY printed system. If the panel is too small for four slots,
    there will be only two by default.


    TODO: Add Slots to the drill template


    screwSlots: options are &#34;auto&#34;, &#34;auto-tlbr&#34;, &#34;auto-trbl&#34;, &#34;auto-center&#34;, &#34;none&#34;, &#34;all&#34;, &#34;tlbr&#34;, &#34;trbl&#34;, &#34;center&#34;
    &#34;&#34;&#34;

    if self.panelAdded == True:
        raise Warning(&#34;Only one panel can be added&#34;)
    else:
        self.panelAdded = True

    self.config[&#34;panelWidth&#34;] = width
    self.config[&#34;panelHeight&#34;] = height

    # Make the main panel shape
    self.panel = self.panel.box(
        self.config[&#34;panelWidth&#34;],
        self.config[&#34;panelHeight&#34;],
        self.config[&#34;panelThickness&#34;],
    )

    # Initialize the drill template
    self.markOutline()

    # Do we add screw slots?
    # default to &#34;none&#34; configuration
    screwSlotTopLeft = False
    screwSlotTopCenter = False
    screwSlotTopRight = False
    screwSlotBottomLeft = False
    screwSlotBottomCenter = False
    screwSlotBottomRight = False
    if (  # If too small for 4 slots
        self.config[&#34;m3screwSlotWidth&#34;] * 2
        + (
            self.config[&#34;m3screwSlotDistanceFromSide&#34;]
            - self.config[&#34;m3screwSlotWidth&#34;] / 2
        )
        * 2
    ) &gt; self.config[&#34;panelWidth&#34;]:
        if screwSlots == &#34;auto&#34;:
            screwSlots = &#34;tlbr&#34;
        if screwSlots == &#34;auto-tlbr&#34;:
            screwSlots = &#34;tlbr&#34;
        if screwSlots == &#34;auto-trbl&#34;:
            screwSlots = &#34;trbl&#34;
        if screwSlots == &#34;auto-center&#34;:
            screwSlots = &#34;center&#34;
    else:  # Large enough for 4 slots
        if screwSlots == &#34;auto&#34;:
            screwSlots = &#34;all&#34;
        if screwSlots == &#34;auto-tlbr&#34;:
            screwSlots = &#34;all&#34;
        if screwSlots == &#34;auto-trbl&#34;:
            screwSlots = &#34;all&#34;
        if screwSlots == &#34;auto-center&#34;:
            screwSlots = &#34;all&#34;
    if screwSlots == &#34;tlbr&#34;:
        screwSlotTopLeft = True
        screwSlotBottomRight = True
    if screwSlots == &#34;trbl&#34;:
        screwSlotTopRight = True
        screwSlotBottomLeft = True
    if screwSlots == &#34;center&#34;:
        screwSlotTopCenter = True
        screwSlotBottomCenter = True
    if screwSlots == &#34;all&#34;:
        screwSlotTopLeft = True
        screwSlotTopRight = True
        screwSlotBottomLeft = True
        screwSlotBottomRight = True

    screwPoints = []
    if screwSlotTopLeft:
        screwPoints.append(
            (
                self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                self.config[&#34;panelHeight&#34;]
                - self.config[&#34;m3screwSlotDistanceFromTop&#34;],
            )
        )
    if screwSlotTopCenter:
        screwPoints.append(
            (
                self.config[&#34;panelWidth&#34;] / 2,
                self.config[&#34;panelHeight&#34;]
                - self.config[&#34;m3screwSlotDistanceFromTop&#34;],
            )
        )
    if screwSlotTopRight:
        screwPoints.append(
            (
                self.config[&#34;panelWidth&#34;]
                - self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                self.config[&#34;panelHeight&#34;]
                - self.config[&#34;m3screwSlotDistanceFromTop&#34;],
            )
        )
    if screwSlotBottomLeft:
        screwPoints.append(
            (
                self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                self.config[&#34;m3screwSlotDistanceFromBottom&#34;],
            )
        )
    if screwSlotBottomCenter:
        screwPoints.append(
            (
                self.config[&#34;panelWidth&#34;] / 2,
                self.config[&#34;m3screwSlotDistanceFromBottom&#34;],
            )
        )
    if screwSlotBottomRight:
        screwPoints.append(
            (
                self.config[&#34;panelWidth&#34;]
                - self.config[&#34;m3screwSlotDistanceFromSide&#34;],
                self.config[&#34;m3screwSlotDistanceFromBottom&#34;],
            )
        )
    if screwPoints != []:
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .workplane()
            .center(-self.config[&#34;panelWidth&#34;] / 2, -self.config[&#34;panelHeight&#34;] / 2)
            .pushPoints(screwPoints)
            .slot2D(
                self.config[&#34;m3screwSlotWidth&#34;],
                self.config[&#34;m3screwSlotHeight&#34;],
                0,
            )
            .cutThruAll()
        )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addPotentiometer"><code class="name flex">
<span>def <span class="ident">addPotentiometer</span></span>(<span>self, x: float, y: float, notchOrientation: str = 'all', lugsOrientation: str = 'all', rotaryEncoderNotch: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Fits most types of panel-mount potentiometers with a 6mm shaft.</p>
<p>There will be four notches around the hole, allowing you to catch the
retaining tab of the potentiometer in the most convenient orientation
possible.</p>
<p>Common rotary encoders such as EC11 could use a thinner panel for the
shaft to protrude sufficiently, in which case, set <code>rotaryEncoderNotch</code>
to <code>True</code> to cut a rectangle in the back of the
panel.</p>
<p>If you want a knob, add it separately with addKnob()</p>
<p>The orientation parameters are seen from the front, and are:
"all", "none", "top", "left", "right", "bottom".</p>
<p>The retaining notches aren't always on the same side, depending on the
type of potentiometer! If in doubt, just leave it to "all" to add 4 notches.</p>
<p>The preview size for the lugs doesn't account for the possibility of bending them,
so it might be safe to have this area overlap other stuff a little.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addPotentiometer(
    self,
    x: float,
    y: float,
    notchOrientation: str = &#34;all&#34;,
    lugsOrientation: str = &#34;all&#34;,
    rotaryEncoderNotch: bool = False,
):
    &#34;&#34;&#34;Fits most types of panel-mount potentiometers with a 6mm shaft.

    There will be four notches around the hole, allowing you to catch the
    retaining tab of the potentiometer in the most convenient orientation
    possible.

    Common rotary encoders such as EC11 could use a thinner panel for the
    shaft to protrude sufficiently, in which case, set `rotaryEncoderNotch`
    to `True` to cut a rectangle in the back of the  panel.

    If you want a knob, add it separately with addKnob()

    The orientation parameters are seen from the front, and are:
    &#34;all&#34;, &#34;none&#34;, &#34;top&#34;, &#34;left&#34;, &#34;right&#34;, &#34;bottom&#34;.

    The retaining notches aren&#39;t always on the same side, depending on the
    type of potentiometer! If in doubt, just leave it to &#34;all&#34; to add 4 notches.

    The preview size for the lugs doesn&#39;t account for the possibility of bending them,
    so it might be safe to have this area overlap other stuff a little.
    &#34;&#34;&#34;
    self.cutPotentiometer(x, y, notchOrientation, rotaryEncoderNotch)
    self.previewPotentiometer(x, y, lugsOrientation)
    self.markPotentiometer(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addRail"><code class="name flex">
<span>def <span class="ident">addRail</span></span>(<span>self, x: float, y: float, hpWidth: int, centered: bool = True, orientation: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a recessed hp rail. The rail is added to the supports layer,
not the panel layer. Good to build cradles: put a Eurorack modules on
a Kosmo faceplate, or 1U on a Eurorack one.</p>
<p>x, y define the center.</p>
<p>orientation is "horizontal" by default, otherwise "vertical"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addRail(
    self,
    x: float,
    y: float,
    hpWidth: int,
    centered: bool = True,
    orientation: str = &#34;horizontal&#34;,
):
    &#34;&#34;&#34;Adds a recessed hp rail. The rail is added to the supports layer,
     not the panel layer. Good to build cradles: put a Eurorack modules on
    a Kosmo faceplate, or 1U on a Eurorack one.

    x, y define the center.

    orientation is &#34;horizontal&#34; by default, otherwise &#34;vertical&#34;
    &#34;&#34;&#34;
    self.cutRail(x, y, hpWidth, centered, orientation)
    self.supportRail(x, y, hpWidth, centered, orientation)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.addSlider"><code class="name flex">
<span>def <span class="ident">addSlider</span></span>(<span>self, x: float, y: float, sliderWidth: float, sliderHeight: float, slotWidth: float, slotHeight: float)</span>
</code></dt>
<dd>
<div class="desc"><p>For slide potentiomenters. Multiple sizes are common, so you have to
specify yours.</p>
<p>No special provision are made to hold them in place, it's assumed you
have a PCB or are will add some glue or something similarly nasty.</p>
<p>x, y: center</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addSlider(
    self,
    x: float,
    y: float,
    sliderWidth: float,
    sliderHeight: float,
    slotWidth: float,
    slotHeight: float,
):
    &#34;&#34;&#34;For slide potentiomenters. Multiple sizes are common, so you have to
    specify yours.

    No special provision are made to hold them in place, it&#39;s assumed you
    have a PCB or are will add some glue or something similarly nasty.

    x, y: center
    &#34;&#34;&#34;
    self.cutSlider(x, y, sliderWidth, sliderHeight, slotWidth, slotHeight)
    self.previewSlider(x, y, sliderWidth, sliderHeight)
    self.markSlider(x, y, sliderWidth, sliderHeight, slotWidth, slotHeight)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutArcadeButton24mm"><code class="name flex">
<span>def <span class="ident">cutArcadeButton24mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutArcadeButton24mm(self, x: float, y: float):
    if not self.config[&#34;panelRender&#34;]:
        return
    self.cutHole(x, y, self.config[&#34;arcade24mmButtonWithTolerance&#34;])
    self.cutHole(
        x,
        y,
        self.config[&#34;arcade24mmButtonAdditionalClearanceDiameter&#34;],
        self.config[&#34;arcade24mmButtonAdditionalClearanceDepth&#34;],
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutArcadeButton30mm"><code class="name flex">
<span>def <span class="ident">cutArcadeButton30mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutArcadeButton30mm(self, x: float, y: float):
    if not self.config[&#34;panelRender&#34;]:
        return
    self.cutHole(x, y, self.config[&#34;arcade30mmButtonWithTolerance&#34;])</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutBigJack"><code class="name flex">
<span>def <span class="ident">cutBigJack</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutBigJack(self, x: float, y: float):
    if not self.config[&#34;panelRender&#34;]:
        return
    self.cutHole(x, y, self.config[&#34;bigJackDiameterWithTolerance&#34;])
    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .center(x, y)
        .rect(
            self.config[&#34;bigJackWidthWithTolerance&#34;],
            self.config[&#34;bigJackHeightWithTolerance&#34;],
        )
        .cutBlind(-self.config[&#34;bigJackNotchDepth&#34;])
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutDisplayWindow"><code class="name flex">
<span>def <span class="ident">cutDisplayWindow</span></span>(<span>self, x: float, y: float, windowWidth: float = 30, windowHeight: float = 15, windowHorizontalOffset: float = 0, windowVerticalOffset: float = -5, screwsHorizontalDistance: float = 40, screwsVerticalDistance: float = 40, addScrews: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutDisplayWindow(
    self,
    x: float,
    y: float,
    windowWidth: float = 30,
    windowHeight: float = 15,
    windowHorizontalOffset: float = 0,
    windowVerticalOffset: float = -5,
    screwsHorizontalDistance: float = 40,
    screwsVerticalDistance: float = 40,
    addScrews: bool = True,
):
    # FIXME: This is the nastiest way possible to implement a fillet
    # but the only one I could figure out.

    cutout = (
        cq.Workplane(&#34;XY&#34;)
        .box(
            windowWidth + self.config[&#34;panelThickness&#34;],
            windowHeight + self.config[&#34;panelThickness&#34;],
            self.config[&#34;panelThickness&#34;],
        )
        .edges(&#34;&gt;Z&#34;)
        .fillet(self.config[&#34;panelThickness&#34;] * 0.99)
        .translate(
            (
                -self.config[&#34;panelWidth&#34;] / 2 + x + windowHorizontalOffset,
                -self.config[&#34;panelHeight&#34;] / 2 + y + windowVerticalOffset,
                0,
            )
        )
    )
    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .cut(cutout)
    )

    # Next, the actual cutout
    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .center(x + windowHorizontalOffset, y + windowVerticalOffset)
        .rect(windowWidth, windowHeight)
        .cutThruAll()
    )

    # Now, the screws
    if addScrews:
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(
                screwsHorizontalDistance,
                screwsVerticalDistance,
                forConstruction=True,
            )
            .vertices()
            .circle(self.config[&#34;m2DiameterWithTolerance&#34;] / 2)
            .cutThruAll()
        )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutHole"><code class="name flex">
<span>def <span class="ident">cutHole</span></span>(<span>self, x: float, y: float, diameter: float, depth: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a circular hole, default depth is through the entire panel</p>
<p>x, y define the center.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutHole(self, x: float, y: float, diameter: float, depth: float = None):
    &#34;&#34;&#34;Makes a circular hole, default depth is through the entire panel

    x, y define the center.&#34;&#34;&#34;
    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .center(x, y)
        .hole(diameter, depth)
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutLed3mm"><code class="name flex">
<span>def <span class="ident">cutLed3mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutLed3mm(self, x: float, y: float):
    if not self.config[&#34;panelRender&#34;]:
        return
    self.cutHole(x, y, self.config[&#34;3mmLedWithTolerance&#34;])</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutLed5mm"><code class="name flex">
<span>def <span class="ident">cutLed5mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutLed5mm(self, x: float, y: float):
    if not self.config[&#34;panelRender&#34;]:
        return
    self.cutHole(x, y, self.config[&#34;5mmLedWithTolerance&#34;])</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutMidiSocket"><code class="name flex">
<span>def <span class="ident">cutMidiSocket</span></span>(<span>self, x: float, y: float, screws: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
    if not self.config[&#34;panelRender&#34;]:
        return
    self.cutHole(x, y, self.config[&#34;midiSocketDiameterWithTolerance&#34;])
    if screws == &#34;horizontal&#34;:
        self.cutHole(
            x - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
            y,
            self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
        )
        self.cutHole(
            x + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
            y,
            self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
        )
    if screws == &#34;vertical&#34;:
        self.cutHole(
            x,
            y - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
            self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
        )
        self.cutHole(
            x,
            y + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
            self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
        )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutMiniJack"><code class="name flex">
<span>def <span class="ident">cutMiniJack</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutMiniJack(self, x: float, y: float):
    if not self.config[&#34;panelRender&#34;]:
        return
    self.cutHole(x, y, self.config[&#34;miniJackDiameterWithTolerance&#34;])
    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .center(x, y)
        .rect(
            self.config[&#34;miniJackSizeWithTolerance&#34;],
            self.config[&#34;miniJackSizeWithTolerance&#34;],
        )
        .cutBlind(-self.config[&#34;miniJackNotchDepth&#34;])
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutMiniToggleSwitch"><code class="name flex">
<span>def <span class="ident">cutMiniToggleSwitch</span></span>(<span>self, x: float, y: float, orientation: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutMiniToggleSwitch(self, x: float, y: float, orientation: str = &#34;horizontal&#34;):
    if not self.config[&#34;panelRender&#34;]:
        return
    if orientation == &#34;horizontal&#34;:
        width = self.config[&#34;miniToggleSwitchWidthWithTolerance&#34;]
        length = self.config[&#34;miniToggleSwitchLengthWithTolerance&#34;]
    else:
        width = self.config[&#34;miniToggleSwitchLengthWithTolerance&#34;]
        length = self.config[&#34;miniToggleSwitchWidthWithTolerance&#34;]

    self.cutHole(x, y, self.config[&#34;miniToggleSwitchDiameterWithTolerance&#34;])
    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .center(x, y)
        .rect(width, length)
        .cutBlind(-self.config[&#34;miniToggleSwitchNotchDepth&#34;])
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutPanelWidthTolerance"><code class="name flex">
<span>def <span class="ident">cutPanelWidthTolerance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Automatically called during <code>render()</code> for Eurorack and 1UIJ:
makes the panel a bit smaller than its nominal size laterally to account
for thermal expansion and misaligned neighboring panels.
Kosmo panels are naturally a bit smaller than the hp grid (they are on a
25mm grid, while hp are on a 5.08mm grid), as a result, they don't need
this shave.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutPanelWidthTolerance(self):
    &#34;&#34;&#34;Automatically called during `render()` for Eurorack and 1UIJ:
    makes the panel a bit smaller than its nominal size laterally to account
    for thermal expansion and misaligned neighboring panels.
    Kosmo panels are naturally a bit smaller than the hp grid (they are on a
    25mm grid, while hp are on a 5.08mm grid), as a result, they don&#39;t need
    this shave.
    &#34;&#34;&#34;
    # FIXME: Trial and error values that make no sense.
    # Something&#39;s broken elsewhere!
    # FIXME: Test print Euro / IJ: Do the tolerances provide enough extrusions?
    if self.config[&#34;panelWidthTolerance&#34;] == 0:
        return
    self.cutRect(
        0,
        0,
        self.config[&#34;panelWidthTolerance&#34;],
        self.config[&#34;panelHeight&#34;] * 2,
        False,
    )

    self.cutRect(
        self.config[&#34;panelWidth&#34;] - self.config[&#34;panelWidthTolerance&#34;] / 2,
        0,
        self.config[&#34;panelWidthTolerance&#34;],
        self.config[&#34;panelHeight&#34;] * 2,
        False,
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutPotentiometer"><code class="name flex">
<span>def <span class="ident">cutPotentiometer</span></span>(<span>self, x: float, y: float, notchOrientation: str = 'all', rotaryEncoderNotch: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutPotentiometer(
    self,
    x: float,
    y: float,
    notchOrientation: str = &#34;all&#34;,
    rotaryEncoderNotch: bool = False,
):
    if not self.config[&#34;panelRender&#34;]:
        return
    self.cutHole(x, y, self.config[&#34;potentiometerHoleDiameterWithTolerance&#34;])
    # List the notches
    points = []  # default to &#34;none&#34; configuration
    if notchOrientation == &#34;top&#34; or notchOrientation == &#34;all&#34;:
        points.append((0, -self.config[&#34;potentiometerNotchDistanceFromCenter&#34;]))
    if notchOrientation == &#34;right&#34; or notchOrientation == &#34;all&#34;:
        points.append((self.config[&#34;potentiometerNotchDistanceFromCenter&#34;], 0))
    if notchOrientation == &#34;bottom&#34; or notchOrientation == &#34;all&#34;:
        points.append((0, self.config[&#34;potentiometerNotchDistanceFromCenter&#34;]))
    if notchOrientation == &#34;left&#34; or notchOrientation == &#34;all&#34;:
        points.append((-self.config[&#34;potentiometerNotchDistanceFromCenter&#34;], 0))
    # Cut the notches
    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .center(x, y)
        .pushPoints(points)
        .hole(
            self.config[&#34;potentiometerNotchDiameter&#34;],
            self.config[&#34;potentiometerNotchDepth&#34;],
        )
    )
    # Notch for the encoder
    if rotaryEncoderNotch:
        self.panel = (
            self.panel.faces(&#34;&gt;Z&#34;)
            .vertices(&#34;&lt;XY&#34;)
            .workplane(centerOption=&#34;CenterOfMass&#34;)
            .center(x, y)
            .rect(
                self.config[&#34;rotaryEncoderWidthWithTolerance&#34;],
                self.config[&#34;rotaryEncoderHeightWithTolerance&#34;],
            )
            .cutBlind(-self.config[&#34;rotaryEncoderNotchDepth&#34;])
        )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutRail"><code class="name flex">
<span>def <span class="ident">cutRail</span></span>(<span>self, x: float, y: float, hpWidth: int, centered: bool = True, orientation: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"><p>Make a hole for a hp rail. The rail is added to the supports layer,
not the panel layer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutRail(
    self,
    x: float,
    y: float,
    hpWidth: int,
    centered: bool = True,
    orientation: str = &#34;horizontal&#34;,
):
    &#34;&#34;&#34;Make a hole for a hp rail. The rail is added to the supports layer,
    not the panel layer.&#34;&#34;&#34;
    if not self.config[&#34;panelRender&#34;]:
        return
    width = hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2
    height = self.config[&#34;railsHeight&#34;] + self.config[&#34;cradleTolerance&#34;] * 2
    if orientation == &#34;vertical&#34;:
        width, height = height, width
    if centered:
        self.cutRect(x, y, width, height, 0, centered)
    else:
        self.cutRect(
            x - self.config[&#34;cradleTolerance&#34;],
            y - self.config[&#34;cradleTolerance&#34;],
            width,
            height,
            0,
            centered,
        )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutRect"><code class="name flex">
<span>def <span class="ident">cutRect</span></span>(<span>self, x: float, y: float, width: float, height: float, depth: float = 0, centered: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Cuts a rectangular shape through the panel.</p>
<p>x, y define the center</p>
<p><code>depth = 0</code> cuts through all.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutRect(
    self,
    x: float,
    y: float,
    width: float,
    height: float,
    depth: float = 0,
    centered: bool = True,
):
    &#34;&#34;&#34;Cuts a rectangular shape through the panel.

    x, y define the center

    `depth = 0` cuts through all.
    &#34;&#34;&#34;

    if depth == 0:
        depth = self.config[&#34;panelThickness&#34;]

    cutout = cq.Workplane(&#34;XY&#34;).box(width, height, depth)

    if centered:
        cutout = cutout.translate(
            (
                -self.config[&#34;panelWidth&#34;] / 2 + x,
                -self.config[&#34;panelHeight&#34;] / 2 + y,
                0,
            )
        )
    else:
        cutout = cutout.translate(
            (
                -self.config[&#34;panelWidth&#34;] / 2 + x + width / 2,
                -self.config[&#34;panelHeight&#34;] / 2 + y + height / 2,
                0,
            )
        )

    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .cut(cutout)
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.cutSlider"><code class="name flex">
<span>def <span class="ident">cutSlider</span></span>(<span>self, x: float, y: float, sliderWidth: float, sliderHeight: float, slotWidth: float, slotHeight: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cutSlider(
    self,
    x: float,
    y: float,
    sliderWidth: float,
    sliderHeight: float,
    slotWidth: float,
    slotHeight: float,
):
    if not self.config[&#34;panelRender&#34;]:
        return
    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .center(x, y)
        .rect(
            sliderWidth,
            sliderHeight,
        )
        .cutBlind(-self.config[&#34;sliderNotchDepth&#34;])
    )
    self.cutRect(x, y, slotWidth, slotHeight, 0, True)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.engraveLine"><code class="name flex">
<span>def <span class="ident">engraveLine</span></span>(<span>self, fromX: float, fromY: float, angle: float, length: float, width: float, depth: float = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Engraves a line on the front of the panel.</p>
<p>If the depth parameter is omitted or 0, the default depth is used.</p>
<p>Be sure to inspect both sides of the print to make sure there aren't
any sections that are too thin!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def engraveLine(
    self,
    fromX: float,
    fromY: float,
    angle: float,
    length: float,
    width: float,
    depth: float = 0,
):
    &#34;&#34;&#34;Engraves a line on the front of the panel.

    If the depth parameter is omitted or 0, the default depth is used.

    Be sure to inspect both sides of the print to make sure there aren&#39;t
    any sections that are too thin!
    &#34;&#34;&#34;
    if not self.config[&#34;panelRender&#34;]:
        return
    if depth == 0:
        depth = self.config[&#34;panelEngravingDepth&#34;]
    cutout = (
        cq.Workplane(&#34;XY&#34;)
        .lineTo(-width / 2, 0)
        .lineTo(-width / 2, -length)
        .lineTo(width / 2, -length)
        .lineTo(width / 2, 0)
        .close()
        .extrude(depth)
        .rotate((0, 0, 0), (0, 0, 1), angle)
        .translate(
            (
                -self.config[&#34;panelWidth&#34;] / 2 + fromX,
                -self.config[&#34;panelHeight&#34;] / 2 + fromY,
                -self.config[&#34;panelThickness&#34;] / 2,
            )
        )
    )
    self.panel = (
        self.panel.faces(&#34;&gt;Z&#34;)
        .vertices(&#34;&lt;XY&#34;)
        .workplane(centerOption=&#34;CenterOfMass&#34;)
        .cut(cutout)
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.exportDrillTemplate"><code class="name flex">
<span>def <span class="ident">exportDrillTemplate</span></span>(<span>self, filename: str = 'DrillTemplate.svg')</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the drill template as a SVG file.</p>
<p>Before you print it, crop and scale it up or down in image editing
software to match the size of one side!</p>
<p>TODO: Make it the perfect size out of the box.</p>
<p>You must activate the layer in the constructor first! Otherwise,
drill marks are not rendered, for performance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportDrillTemplate(self, filename: str = &#34;DrillTemplate.svg&#34;):
    &#34;&#34;&#34;Exports the drill template as a SVG file.

    Before you print it, crop and scale it up or down in image editing
    software to match the size of one side!

    TODO: Make it the perfect size out of the box.

    You must activate the layer in the constructor first! Otherwise,
    drill marks are not rendered, for performance.&#34;&#34;&#34;
    cq.exporters.export(
        self.drillTemplate,
        filename,
        opt={
            &#34;width&#34;: 2000,
            &#34;height&#34;: 2000,
            &#34;marginLeft&#34;: 0,
            &#34;marginTop&#34;: 0,
            &#34;showAxes&#34;: False,
            &#34;projectionDir&#34;: (0.0, 0.0, 1.0),
            &#34;strokeWidth&#34;: 0.25,
            &#34;strokeColor&#34;: (255, 0, 0),
            &#34;hiddenColor&#34;: (0, 0, 255),
            &#34;showHidden&#34;: False,
        },
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markArcadeButton24mm"><code class="name flex">
<span>def <span class="ident">markArcadeButton24mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markArcadeButton24mm(self, x: float, y: float):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markHole(x, y, self.config[&#34;arcade24mmButtonWithTolerance&#34;])
    self.markCross(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markArcadeButton30mm"><code class="name flex">
<span>def <span class="ident">markArcadeButton30mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markArcadeButton30mm(self, x: float, y: float):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markHole(x, y, self.config[&#34;arcade30mmButtonWithTolerance&#34;])
    self.markCross(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markBigJack"><code class="name flex">
<span>def <span class="ident">markBigJack</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markBigJack(self, x: float, y: float):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markHole(x, y, self.config[&#34;bigJackDiameterWithTolerance&#34;])
    self.markCross(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markCross"><code class="name flex">
<span>def <span class="ident">markCross</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a mark on the drill template layer. At typical synth panel
sizes, it will show up as a cross the perfect size for printing out and
using as a drill template.</p>
<p>x, y define the center of the mark as seen from the front.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markCross(self, x: float, y: float):
    &#34;&#34;&#34;Adds a mark on the drill template layer. At typical synth panel
    sizes, it will show up as a cross the perfect size for printing out and
    using as a drill template.

    x, y define the center of the mark as seen from the front.
    &#34;&#34;&#34;
    self.drillTemplate = (
        self.drillTemplate.moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .rect(
            self.config[&#34;DrillTemplateMarkLength&#34;],
            self.config[&#34;DrillTemplateMarkThickness&#34;],
        )
        .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
        .moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .rect(
            self.config[&#34;DrillTemplateMarkThickness&#34;],
            self.config[&#34;DrillTemplateMarkLength&#34;],
        )
        .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markDisplayWindow"><code class="name flex">
<span>def <span class="ident">markDisplayWindow</span></span>(<span>self, x: float, y: float, windowWidth: float = 30, windowHeight: float = 15, windowHorizontalOffset: float = 0, windowVerticalOffset: float = -5, screwsHorizontalDistance: float = 40, screwsVerticalDistance: float = 40, addScrews: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markDisplayWindow(
    self,
    x: float,
    y: float,
    windowWidth: float = 30,
    windowHeight: float = 15,
    windowHorizontalOffset: float = 0,
    windowVerticalOffset: float = -5,
    screwsHorizontalDistance: float = 40,
    screwsVerticalDistance: float = 40,
    addScrews: bool = True,
):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markRect(
        x + windowHorizontalOffset,
        y + windowVerticalOffset,
        windowWidth,
        windowHeight,
    )
    if addScrews:
        self.markHole(
            x - screwsHorizontalDistance / 2,
            y - screwsVerticalDistance / 2,
            self.config[&#34;m2DiameterWithTolerance&#34;],
        )
        self.markHole(
            x + screwsHorizontalDistance / 2,
            y - screwsVerticalDistance / 2,
            self.config[&#34;m2DiameterWithTolerance&#34;],
        )
        self.markHole(
            x - screwsHorizontalDistance / 2,
            y + screwsVerticalDistance / 2,
            self.config[&#34;m2DiameterWithTolerance&#34;],
        )
        self.markHole(
            x + screwsHorizontalDistance / 2,
            y + screwsVerticalDistance / 2,
            self.config[&#34;m2DiameterWithTolerance&#34;],
        )
        self.markCross(
            x - screwsHorizontalDistance / 2,
            y - screwsVerticalDistance / 2,
        )
        self.markCross(
            x + screwsHorizontalDistance / 2,
            y - screwsVerticalDistance / 2,
        )
        self.markCross(
            x - screwsHorizontalDistance / 2,
            y + screwsVerticalDistance / 2,
        )
        self.markCross(
            x + screwsHorizontalDistance / 2,
            y + screwsVerticalDistance / 2,
        )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markHole"><code class="name flex">
<span>def <span class="ident">markHole</span></span>(<span>self, x: float, y: float, diameter: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks a circular hole on the drill template.</p>
<p>x, y define the center.</p>
<p>FIXME: Nasty implementation, and requires marking circles before crosses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markHole(self, x: float, y: float, diameter: float):
    &#34;&#34;&#34;Marks a circular hole on the drill template.

    x, y define the center.

    FIXME: Nasty implementation, and requires marking circles before crosses

    &#34;&#34;&#34;
    self.drillTemplate = (
        self.drillTemplate.moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .circle(diameter / 2)
        .extrude(1)
        .moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .circle(diameter / 2 - self.config[&#34;DrillTemplateMarkThickness&#34;])
        .cutThruAll()
    )
    return</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markLed3mm"><code class="name flex">
<span>def <span class="ident">markLed3mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markLed3mm(self, x: float, y: float):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markHole(x, y, self.config[&#34;3mmLedWithTolerance&#34;])
    self.markCross(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markLed5mm"><code class="name flex">
<span>def <span class="ident">markLed5mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markLed5mm(self, x: float, y: float):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markHole(x, y, self.config[&#34;5mmLedWithTolerance&#34;])
    self.markCross(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markMidiSocket"><code class="name flex">
<span>def <span class="ident">markMidiSocket</span></span>(<span>self, x: float, y: float, screws: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markHole(x, y, self.config[&#34;midiSocketDiameterWithTolerance&#34;])
    self.markCross(x, y)
    if screws == &#34;horizontal&#34;:
        self.markHole(
            x - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
            y,
            self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
        )
        self.markHole(
            x + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
            y,
            self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
        )
        self.markCross(x - self.config[&#34;midiSocketScrewDistance&#34;] / 2, y)
        self.markCross(x + self.config[&#34;midiSocketScrewDistance&#34;] / 2, y)
    if screws == &#34;vertical&#34;:
        self.markHole(
            x,
            y - self.config[&#34;midiSocketScrewDistance&#34;] / 2,
            self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
        )
        self.markHole(
            x,
            y + self.config[&#34;midiSocketScrewDistance&#34;] / 2,
            self.config[&#34;midiSocketScrewDiameterWithTolerance&#34;],
        )
        self.markCross(x, y - self.config[&#34;midiSocketScrewDistance&#34;] / 2)
        self.markCross(x, y + self.config[&#34;midiSocketScrewDistance&#34;] / 2)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markMiniJack"><code class="name flex">
<span>def <span class="ident">markMiniJack</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markMiniJack(self, x: float, y: float):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markHole(x, y, self.config[&#34;miniJackDiameterWithTolerance&#34;])
    self.markCross(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markMiniToggleSwitch"><code class="name flex">
<span>def <span class="ident">markMiniToggleSwitch</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markMiniToggleSwitch(self, x: float, y: float):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markHole(x, y, self.config[&#34;miniToggleSwitchDiameterWithTolerance&#34;])
    self.markCross(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markOutline"><code class="name flex">
<span>def <span class="ident">markOutline</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an outline to the drill template layer. This ensures proper
SVG export. This is automatically done when adding a panel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markOutline(self):
    &#34;&#34;&#34;Add an outline to the drill template layer. This ensures proper
    SVG export. This is automatically done when adding a panel.&#34;&#34;&#34;

    self.drillTemplate = (
        self.drillTemplate.moveTo(  # Top
            0,
            -self.config[&#34;panelHeight&#34;] / 2
            + self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
        )
        .rect(
            self.config[&#34;panelWidth&#34;],
            self.config[&#34;DrillTemplateMarkThickness&#34;],
        )
        .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
        .moveTo(  # Bottom
            0,
            self.config[&#34;panelHeight&#34;] / 2
            - self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
        )
        .rect(
            self.config[&#34;panelWidth&#34;],
            self.config[&#34;DrillTemplateMarkThickness&#34;],
        )
        .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
        .moveTo(  # Left
            -self.config[&#34;panelWidth&#34;] / 2
            + self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
            0,
        )
        .rect(
            self.config[&#34;DrillTemplateMarkThickness&#34;],
            self.config[&#34;panelHeight&#34;],
        )
        .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
        .moveTo(  # Right
            self.config[&#34;panelWidth&#34;] / 2
            - self.config[&#34;DrillTemplateMarkThickness&#34;] / 2,
            0,
        )
        .rect(
            self.config[&#34;DrillTemplateMarkThickness&#34;],
            self.config[&#34;panelHeight&#34;],
        )
        .extrude(self.config[&#34;DrillTemplateMarkThickness&#34;])
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markPotentiometer"><code class="name flex">
<span>def <span class="ident">markPotentiometer</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markPotentiometer(self, x: float, y: float):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markHole(x, y, self.config[&#34;potentiometerHoleDiameterWithTolerance&#34;])
    self.markCross(x, y)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markRect"><code class="name flex">
<span>def <span class="ident">markRect</span></span>(<span>self, x: float, y: float, width: float, height: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks a rectangle on the drill template.</p>
<p>x, y define the center.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markRect(self, x: float, y: float, width: float, height: float):
    &#34;&#34;&#34;Marks a rectangle on the drill template.

    x, y define the center.&#34;&#34;&#34;

    self.drillTemplate = (
        self.drillTemplate.moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .rect(width, height)
        .extrude(1)
        .moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .rect(
            width - self.config[&#34;DrillTemplateMarkThickness&#34;] * 2,
            height - self.config[&#34;DrillTemplateMarkThickness&#34;] * 2,
        )
        .cutThruAll()
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.markSlider"><code class="name flex">
<span>def <span class="ident">markSlider</span></span>(<span>self, x: float, y: float, sliderWidth: float, sliderHeight: float, slotWidth: float, slotHeight: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def markSlider(
    self,
    x: float,
    y: float,
    sliderWidth: float,
    sliderHeight: float,
    slotWidth: float,
    slotHeight: float,
):
    if not self.config[&#34;drillTemplateRender&#34;]:
        return
    self.markRect(x, y, sliderWidth, sliderHeight)
    self.markRect(x, y, slotWidth, slotHeight)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewArcadeButton24mm"><code class="name flex">
<span>def <span class="ident">previewArcadeButton24mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewArcadeButton24mm(self, x: float, y: float):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnFront(x, y, 27, 3.4)
    self.previewCylinderOnFront(x, y, 22, 7)
    self.previewCylinderOnBack(x, y, 24, 24.4)
    self.previewCylinderOnBack(x, y, 28, 6)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewArcadeButton30mm"><code class="name flex">
<span>def <span class="ident">previewArcadeButton30mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewArcadeButton30mm(self, x: float, y: float):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnFront(x, y, 32.3, 3.4)
    self.previewCylinderOnFront(x, y, 24, 7)
    self.previewCylinderOnBack(x, y, 24, 24.4)
    self.previewCylinderOnBack(x, y, 34.8, 6.5)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewBigJack"><code class="name flex">
<span>def <span class="ident">previewBigJack</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewBigJack(self, x: float, y: float):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnFront(x, y, 8.5, 7)
    self.previewCylinderOnFront(x, y, 12.6, 2.2)
    self.previewBoxOnBack(x, y, 16, 16, 27)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewBoxOnBack"><code class="name flex">
<span>def <span class="ident">previewBoxOnBack</span></span>(<span>self, x: float, y: float, width: float, height: float, depth: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a box for preview on the back of the panel.
It will be deeper by half the panel thickness.</p>
<p>x, y define the center.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewBoxOnBack(
    self, x: float, y: float, width: float, height: float, depth: float
):
    &#34;&#34;&#34;Adds a box for preview on the back of the panel.
    It will be deeper by half the panel thickness.

    x, y define the center.&#34;&#34;&#34;
    self.preview = (
        self.preview.moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .rect(width, height)
        .extrude(depth + self.config[&#34;panelThickness&#34;] / 2)
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewBoxOnFront"><code class="name flex">
<span>def <span class="ident">previewBoxOnFront</span></span>(<span>self, x: float, y: float, width: float, height: float, depth: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a box for preview on the front of the panel.
It will be deeper by half the panel thickness.</p>
<p>x, y define the center.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewBoxOnFront(
    self, x: float, y: float, width: float, height: float, depth: float
):
    &#34;&#34;&#34;Adds a box for preview on the front of the panel.
    It will be deeper by half the panel thickness.

    x, y define the center.
    &#34;&#34;&#34;
    self.preview = (
        self.preview.moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .rect(width, height)
        .extrude(-depth - self.config[&#34;panelThickness&#34;] / 2)
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewCylinderOnBack"><code class="name flex">
<span>def <span class="ident">previewCylinderOnBack</span></span>(<span>self, x: float, y: float, diameter: float, depth: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a cylinder for preview on the back of the panel.
It will be deeper by half the panel thickness.</p>
<p>x, y define the center.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewCylinderOnBack(self, x: float, y: float, diameter: float, depth: float):
    &#34;&#34;&#34;Adds a cylinder for preview on the back of the panel.
    It will be deeper by half the panel thickness.

    x, y define the center.&#34;&#34;&#34;
    self.preview = (
        self.preview.moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .circle(diameter / 2)
        .extrude(depth + self.config[&#34;panelThickness&#34;] / 2)
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewCylinderOnFront"><code class="name flex">
<span>def <span class="ident">previewCylinderOnFront</span></span>(<span>self, x: float, y: float, diameter: float, depth: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a cylinder for preview on the front of the panel.
It will be deeper by half the panel thickness.</p>
<p>x, y define the center.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewCylinderOnFront(self, x: float, y: float, diameter: float, depth: float):
    &#34;&#34;&#34;Adds a cylinder for preview on the front of the panel.
    It will be deeper by half the panel thickness.

    x, y define the center.&#34;&#34;&#34;
    self.preview = (
        self.preview.moveTo(
            -self.config[&#34;panelWidth&#34;] / 2 + x,
            -self.config[&#34;panelHeight&#34;] / 2 + y,
        )
        .circle(diameter / 2)
        .extrude(-depth - self.config[&#34;panelThickness&#34;] / 2)
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewKnob"><code class="name flex">
<span>def <span class="ident">previewKnob</span></span>(<span>self, x: float, y: float, diameter: float, depth: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewKnob(self, x: float, y: float, diameter: float, depth: float):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnFront(x, y, diameter, depth + 5)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewLed3mm"><code class="name flex">
<span>def <span class="ident">previewLed3mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewLed3mm(self, x: float, y: float):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnFront(x, y, 2.8, 1)
    self.previewBoxOnBack(x, y, 2.7, 1, 17)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewLed5mm"><code class="name flex">
<span>def <span class="ident">previewLed5mm</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewLed5mm(self, x: float, y: float):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnFront(x, y, 4.7, 3)
    self.previewBoxOnBack(x, y, 4, 1, 17)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewMidiSocket"><code class="name flex">
<span>def <span class="ident">previewMidiSocket</span></span>(<span>self, x: float, y: float, screws: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewMidiSocket(self, x: float, y: float, screws: str = &#34;horizontal&#34;):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnBack(x, y, 14, 16)
    if screws == &#34;horizontal&#34;:
        self.previewBoxOnFront(x, y, 28, 19, 1)
    if screws == &#34;vertical&#34;:
        self.previewBoxOnFront(x, y, 19, 28, 1)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewMiniJack"><code class="name flex">
<span>def <span class="ident">previewMiniJack</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewMiniJack(self, x: float, y: float):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnFront(x, y, 6, 5.5)
    self.previewCylinderOnFront(x, y, 8, 2.2)
    self.previewBoxOnBack(x, y, 9, 10.5, 12.5)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewMiniToggleSwitch"><code class="name flex">
<span>def <span class="ident">previewMiniToggleSwitch</span></span>(<span>self, x: float, y: float, orientation: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewMiniToggleSwitch(
    self, x: float, y: float, orientation: str = &#34;horizontal&#34;
):
    if not self.config[&#34;previewRender&#34;]:
        return
    if orientation == &#34;horizontal&#34;:
        width = self.config[&#34;miniToggleSwitchWidth&#34;]
        length = self.config[&#34;miniToggleSwitchLength&#34;]
    else:
        width = self.config[&#34;miniToggleSwitchLength&#34;]
        length = self.config[&#34;miniToggleSwitchWidth&#34;]
    self.previewBoxOnBack(x, y, width, length, 13.6)
    self.previewCylinderOnFront(x, y, self.config[&#34;miniToggleSwitchDiameter&#34;], 19)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewPanel"><code class="name flex">
<span>def <span class="ident">previewPanel</span></span>(<span>self, x: float, y: float, hpWidth: int, height: float, centered: bool = True, orientation: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewPanel(
    self,
    x: float,
    y: float,
    hpWidth: int,
    height: float,
    centered: bool = True,
    orientation: str = &#34;horizontal&#34;,
):
    if not self.config[&#34;previewRender&#34;]:
        return
    if orientation == &#34;horizontal&#34;:
        if centered:
            self.previewBoxOnFront(
                x + self.config[&#34;cradleTolerance&#34;],
                y
                + height / 2
                - self.config[&#34;railsHeight&#34;] / 2
                + self.config[&#34;cradleTolerance&#34;] * 2,
                hp(hpWidth),
                height,
                1.6,
            )
        else:
            self.previewBoxOnFront(
                x + hp(hpWidth) / 2 + self.config[&#34;cradleTolerance&#34;],
                y + height / 2 + self.config[&#34;cradleTolerance&#34;] * 2,
                hp(hpWidth),
                height,
                1.6,
            )
    else:  # vertical
        if centered:
            self.previewBoxOnFront(
                x
                + height / 2
                - self.config[&#34;railsHeight&#34;] / 2
                + self.config[&#34;cradleTolerance&#34;] * 2,
                y + self.config[&#34;cradleTolerance&#34;],
                height,
                hp(hpWidth),
                1.6,
            )
        else:
            self.previewBoxOnFront(
                x + height / 2 + self.config[&#34;cradleTolerance&#34;] * 2,
                y + hp(hpWidth) / 2 + self.config[&#34;cradleTolerance&#34;],
                height,
                hp(hpWidth),
                1.6,
            )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewPotentiometer"><code class="name flex">
<span>def <span class="ident">previewPotentiometer</span></span>(<span>self, x: float, y: float, lugsOrientation: str = 'all')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewPotentiometer(self, x: float, y: float, lugsOrientation: str = &#34;all&#34;):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnFront(x, y, 6, 21)
    self.previewCylinderOnFront(x, y, 9.6, 1.6)
    self.previewCylinderOnBack(x, y, 16, 8)
    if lugsOrientation == &#34;all&#34; or lugsOrientation == &#34;bottom&#34;:
        self.previewBoxOnBack(x, y + 8, 15, 18, 2.4)
    if lugsOrientation == &#34;top&#34;:
        self.previewBoxOnBack(x, y - 8, 15, 18, 2.4)
    if lugsOrientation == &#34;left&#34;:
        self.previewBoxOnBack(x - 8, y, 18, 15, 2.4)
    if lugsOrientation == &#34;right&#34;:
        self.previewBoxOnBack(x + 8, y, 18, 15, 2.4)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.previewSlider"><code class="name flex">
<span>def <span class="ident">previewSlider</span></span>(<span>self, x: float, y: float, sliderWidth: float, sliderHeight: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previewSlider(
    self, x: float, y: float, sliderWidth: float, sliderHeight: float
):
    if not self.config[&#34;previewRender&#34;]:
        return
    self.previewCylinderOnFront(x, y, 15, 10)
    self.previewBoxOnBack(x, y, sliderWidth, sliderHeight, 22)</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, show_object=False)</span>
</code></dt>
<dd>
<div class="desc"><p>You must call this before displaying or exporting your panel
to post-process it properly.</p>
<p>If you give it the show_object function from Cq Editor as an
argument, it will also display the object. When using Synth Printer
from a different environment, just call without any argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, show_object=False):
    &#34;&#34;&#34;You must call this before displaying or exporting your panel
    to post-process it properly.

    If you give it the show_object function from Cq Editor as an
    argument, it will also display the object. When using Synth Printer
    from a different environment, just call without any argument.
    &#34;&#34;&#34;
    # Shave off the sides of the panel if needed
    self.cutPanelWidthTolerance()
    # Move the supports where they belong
    self.supports = self.supports.translate(
        (0, 0, self.config[&#34;panelThickness&#34;] / 2)
    )
    # Move the drill template above the panel
    self.drillTemplate = self.drillTemplate.translate(
        (0, 0, self.config[&#34;DrillTemplateDistance&#34;])
    )
    # Rotate the layers for viewing
    self.panel = self.panel.rotate((0, 0, 0), (1, 0, 0), 180)
    self.preview = self.preview.rotate((0, 0, 0), (1, 0, 0), 180)
    self.emboss = self.emboss.rotate((0, 0, 0), (1, 0, 0), 180)
    self.supports = self.supports.rotate((0, 0, 0), (1, 0, 0), 180)
    self.drillTemplate = self.drillTemplate.rotate((0, 0, 0), (1, 0, 0), 180)
    # Display the layers if we&#39;re in CQ Editor
    if show_object and self.config[&#34;panelRender&#34;]:
        show_object(
            self.panel,
            name=&#34;panel&#34;,
            options=self.config[&#34;panelShowOptions&#34;],
        )
    if show_object and self.config[&#34;supportsRender&#34;]:
        show_object(
            self.supports,
            name=&#34;supports&#34;,
            options=self.config[&#34;supportsShowOptions&#34;],
        )
    if show_object and self.config[&#34;embossRender&#34;]:
        show_object(
            self.emboss,
            name=&#34;emboss&#34;,
            options=self.config[&#34;embossShowOptions&#34;],
        )
    if show_object and self.config[&#34;previewRender&#34;]:
        show_object(
            self.preview,
            name=&#34;preview&#34;,
            options=self.config[&#34;previewShowOptions&#34;],
        )
    if show_object and self.config[&#34;drillTemplateRender&#34;]:
        show_object(
            self.drillTemplate,
            name=&#34;drillTemplate&#34;,
            options=self.config[&#34;drillTemplateShowOptions&#34;],
        )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.supportBar"><code class="name flex">
<span>def <span class="ident">supportBar</span></span>(<span>self, x: float, y: float, width: float, height: float, depth: float, centered: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a box on the supports layer.</p>
<p>x, y define the top-left of the box as seen from the front</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def supportBar(
    self,
    x: float,
    y: float,
    width: float,
    height: float,
    depth: float,
    centered: bool = False,
):
    &#34;&#34;&#34;Adds a box on the supports layer.

    x, y define the top-left of the box as seen from the front
    &#34;&#34;&#34;
    if not self.config[&#34;supportsRender&#34;]:
        return
    if centered:
        x = -self.config[&#34;panelWidth&#34;] / 2 + x
        y = -self.config[&#34;panelHeight&#34;] / 2 + y
    else:
        x = -self.config[&#34;panelWidth&#34;] / 2 + x + width / 2
        y = -self.config[&#34;panelHeight&#34;] / 2 + y + height / 2
    self.supports = (
        self.supports.moveTo(
            x,
            y,
        )
        .rect(width, height)
        .extrude(depth)
    )</code></pre>
</details>
</dd>
<dt id="synthprinter.SynthPrinter.supportRail"><code class="name flex">
<span>def <span class="ident">supportRail</span></span>(<span>self, _x: float, _y: float, hpWidth: int, centered: bool = True, orientation: str = 'horizontal')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a hp rail to the support layer. Requires a hole from cutRail().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def supportRail(
    self,
    _x: float,
    _y: float,
    hpWidth: int,
    centered: bool = True,
    orientation: str = &#34;horizontal&#34;,
):
    &#34;&#34;&#34;Adds a hp rail to the support layer. Requires a hole from cutRail().&#34;&#34;&#34;
    if not self.config[&#34;supportsRender&#34;]:
        return
    width = hp(hpWidth) + self.config[&#34;cradleTolerance&#34;] * 2
    height = self.config[&#34;railsHeight&#34;] + self.config[&#34;cradleTolerance&#34;] * 2
    if orientation != &#34;horizontal&#34;:
        width, height = height, width

    if centered:
        x = -self.config[&#34;panelWidth&#34;] / 2 + _x
        y = -self.config[&#34;panelHeight&#34;] / 2 + _y
    else:
        x = (
            -self.config[&#34;panelWidth&#34;] / 2
            + _x
            + width / 2
            - self.config[&#34;cradleTolerance&#34;]
        )
        y = (
            -self.config[&#34;panelHeight&#34;] / 2
            + _y
            + height / 2
            - self.config[&#34;cradleTolerance&#34;]
        )

    self.supports = (
        # Extrude on the inside
        self.supports.moveTo(x, y)
        .rect(width, height)
        .extrude(-self.config[&#34;panelThickness&#34;] + self.config[&#34;railsFrontRecess&#34;])
        # Extrude on the back
        .moveTo(x, y)
        .rect(width, height)
        .extrude(self.config[&#34;railsSupportDepthBack&#34;])
    )

    if orientation == &#34;horizontal&#34;:
        x = (
            -self.config[&#34;panelWidth&#34;] / 2
            + _x
            + (self.config[&#34;hp&#34;] - self.config[&#34;railsScrewDiameter&#34;]) / 2
            + self.config[&#34;railsScrewDiameter&#34;] / 2
        )
        if centered:
            x = x - hp(hpWidth) / 2
    else:
        y = (
            -self.config[&#34;panelHeight&#34;] / 2
            + _y
            + (self.config[&#34;hp&#34;] - self.config[&#34;railsScrewDiameter&#34;]) / 2
            + self.config[&#34;railsScrewDiameter&#34;] / 2
        )
        if centered:
            y = y - hp(hpWidth) / 2

    # Can&#39;t get rarray to work here.
    if orientation == &#34;horizontal&#34;:
        for n in range(hpWidth):
            self.supports = (
                self.supports.moveTo(x + n * self.config[&#34;hp&#34;], y)
                .circle(self.config[&#34;railsScrewDiameter&#34;] / 2)
                .cutThruAll()
            )
    else:
        for n in range(hpWidth):
            self.supports = (
                self.supports.moveTo(x, y + n * self.config[&#34;hp&#34;])
                .circle(self.config[&#34;railsScrewDiameter&#34;] / 2)
                .cutThruAll()
            )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="synthprinter.hp" href="#synthprinter.hp">hp</a></code></li>
<li><code><a title="synthprinter.kcol" href="#synthprinter.kcol">kcol</a></code></li>
<li><code><a title="synthprinter.khp" href="#synthprinter.khp">khp</a></code></li>
<li><code><a title="synthprinter.krow" href="#synthprinter.krow">krow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="synthprinter.SynthPrinter" href="#synthprinter.SynthPrinter">SynthPrinter</a></code></h4>
<ul class="">
<li><code><a title="synthprinter.SynthPrinter.add1UIJCradle" href="#synthprinter.SynthPrinter.add1UIJCradle">add1UIJCradle</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.add1UIJPanel" href="#synthprinter.SynthPrinter.add1UIJPanel">add1UIJPanel</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addArcadeButton24mm" href="#synthprinter.SynthPrinter.addArcadeButton24mm">addArcadeButton24mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addArcadeButton30mm" href="#synthprinter.SynthPrinter.addArcadeButton30mm">addArcadeButton30mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addBigJack" href="#synthprinter.SynthPrinter.addBigJack">addBigJack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addCradle" href="#synthprinter.SynthPrinter.addCradle">addCradle</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addDisplayWindow" href="#synthprinter.SynthPrinter.addDisplayWindow">addDisplayWindow</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addEurorackCradle" href="#synthprinter.SynthPrinter.addEurorackCradle">addEurorackCradle</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addEurorackPanel" href="#synthprinter.SynthPrinter.addEurorackPanel">addEurorackPanel</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addKnob" href="#synthprinter.SynthPrinter.addKnob">addKnob</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addKosmoPanel" href="#synthprinter.SynthPrinter.addKosmoPanel">addKosmoPanel</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addLed3mm" href="#synthprinter.SynthPrinter.addLed3mm">addLed3mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addLed5mm" href="#synthprinter.SynthPrinter.addLed5mm">addLed5mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addMidiSocket" href="#synthprinter.SynthPrinter.addMidiSocket">addMidiSocket</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addMiniJack" href="#synthprinter.SynthPrinter.addMiniJack">addMiniJack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addMiniToggleSwitch" href="#synthprinter.SynthPrinter.addMiniToggleSwitch">addMiniToggleSwitch</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addPanel" href="#synthprinter.SynthPrinter.addPanel">addPanel</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addPotentiometer" href="#synthprinter.SynthPrinter.addPotentiometer">addPotentiometer</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addRail" href="#synthprinter.SynthPrinter.addRail">addRail</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.addSlider" href="#synthprinter.SynthPrinter.addSlider">addSlider</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutArcadeButton24mm" href="#synthprinter.SynthPrinter.cutArcadeButton24mm">cutArcadeButton24mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutArcadeButton30mm" href="#synthprinter.SynthPrinter.cutArcadeButton30mm">cutArcadeButton30mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutBigJack" href="#synthprinter.SynthPrinter.cutBigJack">cutBigJack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutDisplayWindow" href="#synthprinter.SynthPrinter.cutDisplayWindow">cutDisplayWindow</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutHole" href="#synthprinter.SynthPrinter.cutHole">cutHole</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutLed3mm" href="#synthprinter.SynthPrinter.cutLed3mm">cutLed3mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutLed5mm" href="#synthprinter.SynthPrinter.cutLed5mm">cutLed5mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutMidiSocket" href="#synthprinter.SynthPrinter.cutMidiSocket">cutMidiSocket</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutMiniJack" href="#synthprinter.SynthPrinter.cutMiniJack">cutMiniJack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutMiniToggleSwitch" href="#synthprinter.SynthPrinter.cutMiniToggleSwitch">cutMiniToggleSwitch</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutPanelWidthTolerance" href="#synthprinter.SynthPrinter.cutPanelWidthTolerance">cutPanelWidthTolerance</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutPotentiometer" href="#synthprinter.SynthPrinter.cutPotentiometer">cutPotentiometer</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutRail" href="#synthprinter.SynthPrinter.cutRail">cutRail</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutRect" href="#synthprinter.SynthPrinter.cutRect">cutRect</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.cutSlider" href="#synthprinter.SynthPrinter.cutSlider">cutSlider</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.defaultConfig" href="#synthprinter.SynthPrinter.defaultConfig">defaultConfig</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.engraveLine" href="#synthprinter.SynthPrinter.engraveLine">engraveLine</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.exportDrillTemplate" href="#synthprinter.SynthPrinter.exportDrillTemplate">exportDrillTemplate</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markArcadeButton24mm" href="#synthprinter.SynthPrinter.markArcadeButton24mm">markArcadeButton24mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markArcadeButton30mm" href="#synthprinter.SynthPrinter.markArcadeButton30mm">markArcadeButton30mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markBigJack" href="#synthprinter.SynthPrinter.markBigJack">markBigJack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markCross" href="#synthprinter.SynthPrinter.markCross">markCross</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markDisplayWindow" href="#synthprinter.SynthPrinter.markDisplayWindow">markDisplayWindow</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markHole" href="#synthprinter.SynthPrinter.markHole">markHole</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markLed3mm" href="#synthprinter.SynthPrinter.markLed3mm">markLed3mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markLed5mm" href="#synthprinter.SynthPrinter.markLed5mm">markLed5mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markMidiSocket" href="#synthprinter.SynthPrinter.markMidiSocket">markMidiSocket</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markMiniJack" href="#synthprinter.SynthPrinter.markMiniJack">markMiniJack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markMiniToggleSwitch" href="#synthprinter.SynthPrinter.markMiniToggleSwitch">markMiniToggleSwitch</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markOutline" href="#synthprinter.SynthPrinter.markOutline">markOutline</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markPotentiometer" href="#synthprinter.SynthPrinter.markPotentiometer">markPotentiometer</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markRect" href="#synthprinter.SynthPrinter.markRect">markRect</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.markSlider" href="#synthprinter.SynthPrinter.markSlider">markSlider</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewArcadeButton24mm" href="#synthprinter.SynthPrinter.previewArcadeButton24mm">previewArcadeButton24mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewArcadeButton30mm" href="#synthprinter.SynthPrinter.previewArcadeButton30mm">previewArcadeButton30mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewBigJack" href="#synthprinter.SynthPrinter.previewBigJack">previewBigJack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewBoxOnBack" href="#synthprinter.SynthPrinter.previewBoxOnBack">previewBoxOnBack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewBoxOnFront" href="#synthprinter.SynthPrinter.previewBoxOnFront">previewBoxOnFront</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewCylinderOnBack" href="#synthprinter.SynthPrinter.previewCylinderOnBack">previewCylinderOnBack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewCylinderOnFront" href="#synthprinter.SynthPrinter.previewCylinderOnFront">previewCylinderOnFront</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewKnob" href="#synthprinter.SynthPrinter.previewKnob">previewKnob</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewLed3mm" href="#synthprinter.SynthPrinter.previewLed3mm">previewLed3mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewLed5mm" href="#synthprinter.SynthPrinter.previewLed5mm">previewLed5mm</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewMidiSocket" href="#synthprinter.SynthPrinter.previewMidiSocket">previewMidiSocket</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewMiniJack" href="#synthprinter.SynthPrinter.previewMiniJack">previewMiniJack</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewMiniToggleSwitch" href="#synthprinter.SynthPrinter.previewMiniToggleSwitch">previewMiniToggleSwitch</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewPanel" href="#synthprinter.SynthPrinter.previewPanel">previewPanel</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewPotentiometer" href="#synthprinter.SynthPrinter.previewPotentiometer">previewPotentiometer</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.previewSlider" href="#synthprinter.SynthPrinter.previewSlider">previewSlider</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.render" href="#synthprinter.SynthPrinter.render">render</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.supportBar" href="#synthprinter.SynthPrinter.supportBar">supportBar</a></code></li>
<li><code><a title="synthprinter.SynthPrinter.supportRail" href="#synthprinter.SynthPrinter.supportRail">supportRail</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>